{
  "openapi": "3.0.2",
  "servers": [
    {
      "description": "Production server for the HERE Routing Service",
      "url": "https://router.hereapi.com/v8"
    }
  ],
  "info": {
    "description": "A location service providing customizable route calculations for a variety of vehicle types as well as pedestrian modes.",
    "license": {
      "name": "HERE Documentation License",
      "url": "https://legal.here.com/en-gb/terms/documentation-license"
    },
    "termsOfService": "http://developer.here.com/terms-conditions",
    "title": "Routing API v8",
    "version": "8.58.3",
    "x-apisguru-categories": [
      "location"
    ],
    "x-document-meta-data": {
      "copyright": "© 2023 HERE Europe B.V.",
      "date-created": "2023-02-21T15:56:22+00:00",
      "document-id": "290a7d22-6810-4e1b-8ba5-a35537f64a94"
    },
    "x-logo": {
      "backgroundColor": "#FFFFFF",
      "url": "https://mobidatalab.github.io/mdl-catalog-api/v2/cache/logo/https_avatars.githubusercontent.com_u_2835506.png"
    },
    "x-origin": [
      {
        "format": "openapi",
        "url": "https://developer.here.com/documentation/routing-api/swagger/v8.yaml",
        "version": "3.0"
      }
    ],
    "x-preferred": true,
    "x-providerName": "here.com",
    "x-serviceName": "routing"
  },
  "security": [
    {
      "Bearer": []
    },
    {
      "ApiKey": []
    }
  ],
  "tags": [
    {
      "name": "Routing"
    },
    {
      "description": "Additional API Information",
      "name": "API Information"
    }
  ],
  "paths": {
    "/health": {
      "get": {
        "description": "Returns the health of the service",
        "operationId": "getHealth",
        "parameters": [
          {
            "$ref": "#/components/parameters/xRequestId"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/HealthResponseOkWithRequestID"
          },
          "default": {
            "$ref": "#/components/responses/HealthResponseFailWithRequestID"
          }
        },
        "security": [],
        "summary": "Health status of the service",
        "tags": [
          "API Information"
        ]
      }
    },
    "/import": {
      "post": {
        "description": "Creates a route from a sequence of trace points.\n\nPost body size limit is 10MiB.\n",
        "operationId": "importRoute",
        "parameters": [
          {
            "$ref": "#/components/parameters/transportMode"
          },
          {
            "$ref": "#/components/parameters/departureTimeWithAny"
          },
          {
            "$ref": "#/components/parameters/avoid"
          },
          {
            "$ref": "#/components/parameters/exclude"
          },
          {
            "$ref": "#/components/parameters/units"
          },
          {
            "$ref": "#/components/parameters/lang"
          },
          {
            "$ref": "#/components/parameters/return"
          },
          {
            "$ref": "#/components/parameters/spans"
          },
          {
            "$ref": "#/components/parameters/truck"
          },
          {
            "$ref": "#/components/parameters/vehicle"
          },
          {
            "$ref": "#/components/parameters/evConsumption"
          },
          {
            "$ref": "#/components/parameters/xRequestId"
          },
          {
            "$ref": "#/components/parameters/scooter"
          },
          {
            "$ref": "#/components/parameters/taxi"
          }
        ],
        "requestBody": {
          "content": {
            "application/geo+json": {
              "schema": {
                "$ref": "#/components/schemas/ImportGeoBody"
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MatchTrace"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/RoutesResponseOk"
          },
          "400": {
            "$ref": "#/components/responses/InvalidRoutesRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/401ErrorResponseWithRequestID"
          },
          "403": {
            "$ref": "#/components/responses/Routing403ErrorResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorRoutesResponse"
          }
        },
        "summary": "Calculate a route from a sequence of trace points",
        "tags": [
          "Routing"
        ]
      }
    },
    "/routes": {
      "get": {
        "description": "Calculates a route using a generic vehicle/pedestrian mode, e.g. car, truck, pedestrian, etc...",
        "operationId": "calculateRoutes",
        "responses": {
          "200": {
            "$ref": "#/components/responses/RoutesResponseOk"
          },
          "400": {
            "$ref": "#/components/responses/InvalidRoutesRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/401ErrorResponseWithRequestID"
          },
          "403": {
            "$ref": "#/components/responses/Routing403ErrorResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorRoutesResponse"
          }
        },
        "summary": "Calculate routes via GET",
        "tags": [
          "Routing"
        ]
      },
      "parameters": [
        {
          "$ref": "#/components/parameters/transportMode"
        },
        {
          "$ref": "#/components/parameters/origin"
        },
        {
          "$ref": "#/components/parameters/destination"
        },
        {
          "$ref": "#/components/parameters/via"
        },
        {
          "$ref": "#/components/parameters/departureTimeWithAny"
        },
        {
          "$ref": "#/components/parameters/arrivalTime"
        },
        {
          "$ref": "#/components/parameters/routingMode"
        },
        {
          "$ref": "#/components/parameters/alternatives"
        },
        {
          "$ref": "#/components/parameters/avoid"
        },
        {
          "$ref": "#/components/parameters/exclude"
        },
        {
          "$ref": "#/components/parameters/units"
        },
        {
          "$ref": "#/components/parameters/lang"
        },
        {
          "$ref": "#/components/parameters/return"
        },
        {
          "$ref": "#/components/parameters/spans"
        },
        {
          "$ref": "#/components/parameters/truck"
        },
        {
          "$ref": "#/components/parameters/vehicle"
        },
        {
          "$ref": "#/components/parameters/ev"
        },
        {
          "$ref": "#/components/parameters/pedestrianSpeed"
        },
        {
          "$ref": "#/components/parameters/xRequestId"
        },
        {
          "$ref": "#/components/parameters/scooter"
        },
        {
          "$ref": "#/components/parameters/currency"
        },
        {
          "$ref": "#/components/parameters/customizations"
        },
        {
          "$ref": "#/components/parameters/taxi"
        },
        {
          "$ref": "#/components/parameters/tolls"
        },
        {
          "$ref": "#/components/parameters/maxSpeedOnSegment"
        },
        {
          "$ref": "#/components/parameters/traffic"
        }
      ],
      "post": {
        "description": "Calculates a route using a generic vehicle/pedestrian mode, e.g. car, truck, pedestrian, etc...\n\nAt the moment, only select parameters are permitted in the POST payload. In particular, those parameters\nthat due to request size may be limited in the query string. See the request body section below. These\nparameters can be provided either in the query string or in the POST body. However, if a parameter is\nprovided in both, the request will fail. All other parameters can only be provided in the query string\nat the moment.\n\nPost body size limit is 10MiB.\n",
        "operationId": "calculateRoutesPost",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CalculateRoutesPostParameters"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/RoutesResponseOk"
          },
          "400": {
            "$ref": "#/components/responses/InvalidRoutesRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/401ErrorResponseWithRequestID"
          },
          "403": {
            "$ref": "#/components/responses/Routing403ErrorResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorRoutesResponse"
          }
        },
        "summary": "Calculate routes via POST",
        "tags": [
          "Routing"
        ]
      }
    },
    "/routes/{routeHandle}": {
      "get": {
        "description": "Decodes and returns a route from a previously calculated route handle.\n\n**Disclaimer: A route handle is not suitable for persistent route storage! It can be\ninvalidated at any time.**\n\nA route handle encodes a previously calculated route. A route can be decoded from a handle\nas long as the service uses the same map data and encoding that were used when retrieving the handle.\n\nThus it is suitable for caching routes compactly. It can be used to retrieve updated traffic\ninformation or other data along the route. However, a user should be prepared to recalculate\nthe route when decoding the handle fails.\n\nAll parameters of the `/routes` endpoint are supported, except for `destination`, `via`,\n`alternatives` and `routingMode`. See also the `return` parameter of `/routes` endpoint.\n\nThe `origin` parameter can be provided to update the start of the previously calculated\nroute.\n\nThe `transportMode` parameter does not have to match the transport mode previously used for\nroute calculation. However, when using a different transport mode, the request may fail,\ne.g. when the route has road segments forbidden for the provided transport mode.\n\nPlease refer to the developers' guide for more information and examples.\n",
        "operationId": "getRoutesByHandle",
        "responses": {
          "200": {
            "$ref": "#/components/responses/RoutesResponseOk"
          },
          "400": {
            "$ref": "#/components/responses/InvalidRoutesRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/401ErrorResponseWithRequestID"
          },
          "403": {
            "$ref": "#/components/responses/Routing403ErrorResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorRoutesResponse"
          }
        },
        "summary": "Get route by handle via GET",
        "tags": [
          "Routing"
        ]
      },
      "parameters": [
        {
          "$ref": "#/components/parameters/routeHandle"
        },
        {
          "$ref": "#/components/parameters/transportMode"
        },
        {
          "$ref": "#/components/parameters/routeHandleOrigin"
        },
        {
          "$ref": "#/components/parameters/departureTimeWithAny"
        },
        {
          "$ref": "#/components/parameters/avoid"
        },
        {
          "$ref": "#/components/parameters/exclude"
        },
        {
          "$ref": "#/components/parameters/units"
        },
        {
          "$ref": "#/components/parameters/lang"
        },
        {
          "$ref": "#/components/parameters/return"
        },
        {
          "$ref": "#/components/parameters/spans"
        },
        {
          "$ref": "#/components/parameters/truck"
        },
        {
          "$ref": "#/components/parameters/vehicle"
        },
        {
          "$ref": "#/components/parameters/evConsumption"
        },
        {
          "$ref": "#/components/parameters/pedestrianSpeed"
        },
        {
          "$ref": "#/components/parameters/xRequestId"
        },
        {
          "$ref": "#/components/parameters/scooter"
        },
        {
          "$ref": "#/components/parameters/currency"
        },
        {
          "$ref": "#/components/parameters/rerouting"
        },
        {
          "$ref": "#/components/parameters/taxi"
        },
        {
          "$ref": "#/components/parameters/tolls"
        },
        {
          "$ref": "#/components/parameters/maxSpeedOnSegment"
        },
        {
          "$ref": "#/components/parameters/traffic"
        }
      ],
      "post": {
        "description": "Decodes and returns a route from a previously calculated route handle.\n\n**Disclaimer: A route handle is not suitable for persistent route storage! It can be\ninvalidated at any time.**\n\nA route handle encodes a previously calculated route. A route can be decoded from a handle\nas long as the service uses the same map data and encoding that were used when retrieving the handle.\n\nThus it is suitable for caching routes compactly. It can be used to retrieve updated traffic\ninformation or other data along the route. However, a user should be prepared to recalculate\nthe route when decoding the handle fails.\n\nAll parameters of the `/routes` endpoint are supported, except for `destination`, `via`,\n`alternatives` and `routingMode`. See also the `return` parameter of `/routes` endpoint.\n\nThe `origin` parameter can be provided to update the start of the previously calculated\nroute.\n\nThe `transportMode` parameter does not have to match the transport mode previously used for\nroute calculation. However, when using a different transport mode, the request may fail,\ne.g. when the route has road segments forbidden for the provided transport mode.\n\nParameters can be provided either in the query string or some selected ones also in the POST\nbody. If a parameter is provided in both, the request will fail.\n\nPost body size limit is 10MiB.\n\nPlease refer to the developers' guide for more information and examples.\n",
        "operationId": "getRoutesByHandlePost",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRoutesByHandlePostParameters"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/RoutesResponseOk"
          },
          "400": {
            "$ref": "#/components/responses/InvalidRoutesRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/401ErrorResponseWithRequestID"
          },
          "403": {
            "$ref": "#/components/responses/Routing403ErrorResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorRoutesResponse"
          }
        },
        "summary": "Get route by handle via POST",
        "tags": [
          "Routing"
        ]
      }
    },
    "/version": {
      "get": {
        "description": "Returns the version of the service",
        "operationId": "getVersion",
        "parameters": [
          {
            "$ref": "#/components/parameters/xRequestId"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/VersionResponseOkWithRequestID"
          },
          "500": {
            "$ref": "#/components/responses/500ErrorResponseWithRequestID"
          },
          "502": {
            "$ref": "#/components/responses/502ErrorResponseWithRequestID"
          },
          "503": {
            "$ref": "#/components/responses/503ErrorResponseWithRequestID"
          },
          "504": {
            "$ref": "#/components/responses/504ErrorResponseWithRequestID"
          }
        },
        "security": [],
        "summary": "Full version of the API",
        "tags": [
          "API Information"
        ]
      }
    }
  },
  "components": {
    "examples": {
      "400RoutingErrorResponseExample": {
        "value": {
          "action": "",
          "cause": "missing field `destination`",
          "code": "E605001",
          "correlationId": "4199533b-6290-41db-8d79-edf4f4019a74",
          "status": 400,
          "title": "Malformed request"
        }
      },
      "401errorResponseExample": {
        "value": {
          "error": "Unauthorized",
          "error_description": "No credentials found"
        }
      },
      "403RoutingErrorResponseExample": {
        "value": {
          "action": "Obtain credentials that allow you to calculate routes in Japan",
          "cause": "Your credentials are not allowed to calculate routes in Japan",
          "code": "E605101",
          "correlationId": "4199533b-6290-41db-8d79-edf4f4019a74",
          "status": 403,
          "title": "Not allowed"
        }
      },
      "500RoutingErrorResponseExample": {
        "value": {
          "action": "",
          "cause": "",
          "code": "E605500",
          "correlationId": "4199533b-6290-41db-8d79-edf4f4019a74",
          "status": 500,
          "title": "Internal server error"
        }
      },
      "500errorResponseExample": {
        "value": {
          "action": "",
          "cause": "Internal Server Error",
          "code": "E600103",
          "correlationId": "",
          "status": 500,
          "title": "failed with reason: internal server error"
        }
      },
      "502errorResponseExample": {
        "value": {
          "action": "",
          "cause": "Bad Gateway",
          "code": "E600002",
          "correlationId": "",
          "status": 502,
          "title": "failed with reason: bad gateway"
        }
      },
      "503errorResponseExample": {
        "value": {
          "action": "",
          "cause": "Service Unavailable",
          "code": "E600001",
          "correlationId": "",
          "status": 503,
          "title": "failed with reason: service unavailable"
        }
      },
      "504errorResponseExample": {
        "value": {
          "action": "",
          "cause": "Gateway Timeout",
          "code": "E600000",
          "correlationId": "",
          "status": 504,
          "title": "failed with reason: gateway timeout"
        }
      },
      "ReroutingExample": {
        "value": {
          "lastTraveledSectionIndex": 0,
          "mode": "returnToRoute",
          "traveledDistanceOnLastSection": 142
        }
      },
      "VersionResponseOkExample": {
        "value": [
          {
            "apiVersion": "8.18.0"
          },
          {
            "serviceVersion": "2022-12-15-b706cc8c-9057409"
          },
          {
            "dataVersions": [
              {
                "name": "traffic-feed",
                "version": "2023-01-31T14:41:36+00:00"
              },
              {
                "name": "hrn:here:data::olp-here:rib-2",
                "version": "4898"
              },
              {
                "name": "hrn:here:data::olp-here:here-map-content-japan-2",
                "version": "65"
              },
              {
                "name": "optimized-map-for-routing",
                "version": "2022.346.5.48"
              }
            ]
          }
        ]
      },
      "calculateRoutesPostParametersExample": {
        "value": {
          "avoid": {
            "areas": [
              "polygon:52.416,13.082;52.626,13.628;52.916,13.482",
              "polygon:BG8mnlkD6-9wZAmrR19DAAlrR",
              "bbox:13.082,52.416,13.628,52.626"
            ],
            "segments": [
              "here:cm:segment:99994525"
            ]
          },
          "ev": {
            "preferredBrands": [
              "6e1a148e8ddf06f613599134197b7c1c",
              "6211c90a063d36429b599dda79ae85e3"
            ]
          }
        }
      },
      "matchTraceExample": {
        "value": {
          "trace": [
            {
              "lat": 52,
              "lng": 13.1
            },
            {
              "lat": 52.1,
              "lng": 13.2
            },
            {
              "lat": 52.2,
              "lng": 13.3
            }
          ],
          "via": [
            {
              "index": 1
            }
          ]
        }
      },
      "noticeWithRestrictionsExample": {
        "description": "Example of a notice indicating violation of a restriction that applies to vehicles\nover 12 tons and having between 2 and 4 axles (inclusive).\n",
        "value": {
          "code": "violatedVehiceRestriction",
          "details": [
            {
              "axleCount": {
                "from": 2,
                "to": 4
              },
              "cause": "Route violates vehicle restriction",
              "maxGrossWeight": 12000,
              "type": "restriction"
            }
          ],
          "severity": "critical",
          "title": "Violated vehicle restriction."
        }
      },
      "restrictionExample": {
        "description": "Example modeling the following set of conditions which apply on one section of a road:\n* 12t weight\n* 3m height\n* forbidden transportation of gas\n",
        "value": {
          "forbiddenHazardousGoods": [
            "gas"
          ],
          "maxGrossWeight": 12000,
          "maxHeight": 300,
          "type": "restriction"
        }
      },
      "routeResponseExample": {
        "value": {
          "routes": [
            {
              "id": "1793a897-0843-4957-ab63-c61e0f13aff2",
              "sections": [
                {
                  "actions": [
                    {
                      "action": "depart",
                      "duration": 126,
                      "instruction": "Head toward Chausseestraße on Invalidenstraße. Go for 1.2 km.",
                      "offset": 0
                    },
                    {
                      "action": "arrive",
                      "duration": 0,
                      "instruction": "Arrive at Invalidenstraße.",
                      "offset": 78
                    }
                  ],
                  "arrival": {
                    "place": {
                      "location": {
                        "lat": 52.52639072947204,
                        "lng": 13.368653766810894
                      },
                      "type": "place"
                    },
                    "time": "2019-12-05T15:18:02+01:00"
                  },
                  "departure": {
                    "place": {
                      "location": {
                        "lat": 52.53100287169218,
                        "lng": 13.38464098982513
                      },
                      "type": "place"
                    },
                    "time": "2019-12-05T15:15:56+01:00"
                  },
                  "id": "c3e300ab-a880-4fab-9bb2-702355b2bf6b",
                  "polyline": "BG2znmkDi89wZ9ChKAA1IvfAArH5cAArHvbAA1CrJAArF5SAAtP9yBAAT1E3E3QAA_BrH3M9sBAA_F5SAA3KlkBAA1EtNAApB_DAAhC1EAApB1I_D5OAA3ErPAApFtTAAtN_wBAA1GtVAA5U3lCAA_DhOAA3KliBAAtXjvCAArDtLAA1EhQAA1CrJAA_BrFAAvbl9CAAhIvZ_FtTrDtLAAV1I1CtNAA1E3QAArLnoB1G5YAAhGhSpBrFAAhC1GAA1FxT",
                  "spans": [
                    {
                      "length": 787,
                      "names": [
                        {
                          "language": "de",
                          "value": "Invalidenstraße"
                        }
                      ],
                      "offset": 0
                    },
                    {
                      "length": 51,
                      "names": [
                        {
                          "language": "de",
                          "value": "Invalidenstraße"
                        },
                        {
                          "language": "de",
                          "value": "Sandkrugbrücke"
                        }
                      ],
                      "offset": 49
                    },
                    {
                      "length": 362,
                      "names": [
                        {
                          "language": "de",
                          "value": "Invalidenstraße"
                        }
                      ],
                      "offset": 57
                    }
                  ],
                  "summary": {
                    "duration": 126,
                    "length": 1200
                  },
                  "transport": {
                    "mode": "car"
                  },
                  "type": "vehicle"
                }
              ]
            }
          ]
        }
      },
      "routeResponseNoticeExample": {
        "value": {
          "code": "couldNotMatchOrigin",
          "severity": "critical",
          "title": "Route calculation failed: Couldn't match origin."
        }
      }
    },
    "headers": {
      "X-Correlation-Id": {
        "description": "Auto-generated id that univocally identifies the request.",
        "example": "4199533b-6290-41db-8d79-edf4f4019a74",
        "schema": {
          "type": "string"
        }
      },
      "X-Request-Id": {
        "description": "User-provided token that can be used to trace a request or a group of requests sent to the service.",
        "example": "8230d7ad-3f1c-4191-a8dd-f3c42026da89",
        "schema": {
          "type": "string"
        }
      }
    },
    "parameters": {
      "alternatives": {
        "description": "Number of alternative routes to return aside from the optimal route.",
        "in": "query",
        "name": "alternatives",
        "required": false,
        "schema": {
          "default": 0,
          "maximum": 6,
          "minimum": 0,
          "type": "integer"
        }
      },
      "arrivalTime": {
        "allowReserved": true,
        "description": "Specifies the time of arrival as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).\nThe requested time is converted to the local time at destination. When the optional timezone offset is\nnot specified, time is assumed to be local.\nAll `Time` values in the response are returned in the timezone of each location.\n\nNote : The following features do not support the arrivalTime parameter:\n* EV Routing\n* Route Handle\n* Route Import\n",
        "in": "query",
        "name": "arrivalTime",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/Time"
        }
      },
      "avoid": {
        "allowReserved": true,
        "description": "Avoid routes that violate certain features of road network or that go through\nuser-specified geographical bounding boxes.\n\nNote that if the origin, destination, or any via is in an avoided area or on an avoided\nfeature, a route is produced that violates the avoid restriction. In such a case, the\nroute is trying to minimize the violation of the avoid restrictions and can therefore\ninclude large deviations from a route that is calculated without these avoid\nrestrictions.\n\nIt is also possible that the produced route violates the avoid restriction in between\nwaypoints, if no other route is possible or too hard to find. One such example is\nrequesting a route to an island that is only reachable with ferries while specifying\n`avoid[features]=ferry`.\n\nFurther, avoid can cause the route calculation to fail, if no route is possible or too\nhard to find.\n\nSpecify properties using array notation like `avoid[features]=controlledAccessHighway,tunnel`.\n",
        "examples": {
          "area": {
            "summary": "Avoid a specific geographical bounding box",
            "value": {
              "areas": "bbox:13.082,52.416,13.628,52.626"
            }
          },
          "areas": {
            "summary": "Avoid multiple geographical bounding boxes using `|` as element separator",
            "value": {
              "areas": "bbox:13.3127778,52.5106221,13.3495852,52.5255681|bbox:13.3958343,52.5171209,13.4286456,52.5405511"
            }
          },
          "complete": {
            "summary": "Avoid both features and geographical bounding boxes",
            "value": {
              "features": "tollRoad,tunnel&avoid[areas]=bbox:13.082,52.416,13.628,52.626"
            }
          },
          "features": {
            "summary": "Avoid specific features like `tunnel' or `ferry`",
            "value": {
              "features": "tunnel,ferry"
            }
          },
          "segment": {
            "summary": "Avoid a segment using its identifier",
            "value": {
              "segments": "here:cm:segment:207551710"
            }
          },
          "segmentsWithDirection": {
            "summary": "Avoid two segments using their identifiers, also specifying the direction",
            "value": {
              "segments": "here:cm:segment:207551710#+,here:cm:segment:76771992#*"
            }
          },
          "tollTransponders": {
            "summary": "Avoid all toll transponders",
            "value": {
              "tollTransponders": "all"
            }
          },
          "truckRoadTypes": {
            "summary": "Avoid the specified truck road types",
            "value": {
              "truckRoadTypes": "BK1,BK2,BK3,BK4"
            }
          },
          "zoneCategory": {
            "summary": "Avoid all environmental zones",
            "value": {
              "zoneCategories": "environmental"
            }
          },
          "zoneCategoryWithException": {
            "summary": "Avoid all environmental zones except a specific one",
            "value": {
              "zoneCategories": "environmental;exceptZoneIds=here:cm:envzone:2"
            }
          },
          "zones": {
            "summary": "Avoid multiple environmental zones using identifiers",
            "value": {
              "zoneIdentifiers": "here:cm:envzone:2,here:cm:envzone:3"
            }
          }
        },
        "in": "query",
        "name": "avoid",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/Avoid"
        },
        "style": "deepObject"
      },
      "currency": {
        "description": "Currency code compliant to ISO 4217.\nCosts for the calculated route will be returned using this currency.\n\nIf not provided, the router will specify it.\nOn a best-effort basis, the router will try to specify the costs in the local currency.\n",
        "in": "query",
        "name": "currency",
        "required": false,
        "schema": {
          "type": "string"
        }
      },
      "customizations": {
        "allowReserved": true,
        "description": "Specifies a list of customizations to be used. The data provided by these customizations either\nreplaces or augments the standard HERE map data. The provided credentials must authorize access\nto all of the customizations specified.\n\n**Alpha**: This API is in development. It may not be stable and is subject to change.\n",
        "in": "query",
        "name": "customizations",
        "required": false,
        "schema": {
          "items": {
            "$ref": "#/components/schemas/CustomizationHRN"
          },
          "type": "array"
        }
      },
      "departureTimeWithAny": {
        "allowReserved": true,
        "description": "Specifies the time of departure as defined by either `date-time` or `full-date` `T`\n`partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).\n\nThe requested time is converted to local time at origin. When the optional timezone offset\nis not specified, time is assumed to be local. The special value `any` can be used to\nindicate that time should not be taken into account during routing. If neither\n`departureTime` or `arrivalTime` are specified, current time at departure place will be\nused. All time values in the response are returned in the timezone of each location.\n",
        "in": "query",
        "name": "departureTime",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/TimeWithAny"
        }
      },
      "destination": {
        "allowReserved": true,
        "description": "A location defining the destination of the trip.\n\n## Format\n\nFormat: `Place[WaypointOptions]`\n\n* Place: `{lat},{lng}[PlaceOptions]`\n* PlaceOptions: `;option1=value1;option2=value2...`\n* WaypointOptions: `!option1=value1!option2=value2...`\n\nA waypoint consists of:\n\n* Exactly one place\n* Optional settings for the place\n* Optional settings for the waypoint itself\n\nSupported place options:\n\n* `course`: int, degrees clock-wise from north. Indicating desired direction at the place.\n  E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance`\n* `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be\n  used. E.g. if the location is to the left of the street, the router will prefer using\n  that side in case the street has dividers. E.g.\n  `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`\n  side of the street should be preferred. This option is required, if `matchSideOfStreet`\n  is set to `always`.\n* `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by\n  `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as\n  well.\n  + `always` : Always prefer the given side of street.\n  + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case\n    the street has dividers. This is the default behavior.\n* `nameHint`: string. Causes the router to look for the place with the most similar name.\n  This can e.g. include things like: `North` being used to differentiate between\n  interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly\n  select a residental street.\n* `radius`: int, meters. Asks the router to consider all places within the given radius as\n  potential candidates for route calculation. This can be either because it is not\n  important which place is used, or because it is unknown. Radius more than 200meter are\n  not supported.\n* `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.\n  For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions.\n* `customizationIndex`: int. Specifies the zero-based index into the list of customizations\n  specified in the `customizations` parameter. The customization at that index must be an\n  Extension Map.\n  Providing a `customizationIndex` indicates the this waypoint is located within that\n  Extension Map.\n  **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change.\n* `segmentIdHint`: string. Causes the router to try and match to the specified segment.\n  Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint\n  This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one.\n* `onRoadThreshold`: int, meters. allows specifying a distance within which\n  the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.\n  Within this threshold, the attributes of the segments do not impact the matching.\n  Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.\n\nSupported waypoint options:\n\n* `stopDuration`: desired duration for the stop, in seconds. The section arriving at this\n  via waypoint will have a `wait` post action reflecting the stopping time. The\n  consecutive section will start at the arrival time of the former section + stop\n  duration.\n* `passThrough`: option is not supported for 'destination'.\n\nNotes:\n\n* Non-structural reserved characters in options' values need to be properly percent-encoded.\n  Please refer to the developers' guide for more details.\n",
        "examples": {
          "coordinate": {
            "summary": "A simple WGS84 coordinate",
            "value": "51.611571,11.351608"
          },
          "course": {
            "summary": "Setting course/radius/minCourseDistance an uncertain GPS coordinate of a moving vehicle",
            "value": "51.611571,11.351608;course=170;radius=20;minCourseDistance=500"
          },
          "duration": {
            "summary": "Addition a stopDuration for an intermediate stop",
            "value": "51.611571,11.351608!stopDuration=600"
          },
          "name": {
            "summary": "Setting nameHint to avoid matching to the wrong location",
            "value": "52.510319,13.285616;nameHint=Kaiserdamm"
          },
          "side": {
            "summary": "Populating sideOfStreetHint in addition to location to avoid ending on the wrong side of the street",
            "value": "52.531052,13.384872;sideOfStreetHint=52.530941,13.384939;matchSideOfStreet=always"
          }
        },
        "in": "query",
        "name": "destination",
        "required": true,
        "schema": {
          "$ref": "#/components/schemas/Waypoint"
        }
      },
      "ev": {
        "allowReserved": true,
        "in": "query",
        "name": "ev",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/EV"
        },
        "style": "deepObject"
      },
      "evConsumption": {
        "allowReserved": true,
        "in": "query",
        "name": "ev",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/EVConsumption"
        },
        "style": "deepObject"
      },
      "exclude": {
        "description": "Defines properties which will be strictly excluded from route calculation.\n\nNote - Exclude countries guarantees exclusion, but doesn't guarantee\nfinding a route.\n",
        "examples": {
          "countries": {
            "summary": "Exclude both the country of Switzerland and the country of Austria from the route calculation",
            "value": {
              "countries": "CHE,AUT"
            }
          },
          "country": {
            "summary": "Exclude the country of Switzerland from the route calculation",
            "value": {
              "countries": "CHE"
            }
          }
        },
        "in": "query",
        "name": "exclude",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/Exclude"
        },
        "style": "deepObject"
      },
      "lang": {
        "description": "Specifies the list of preferred languages of the response.\nThe first supported language from the list will be used for for the response.\nThe value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt).\nA list of supported languages for the routing service can be found in the dev guide https://developer.here.com/documentation/routing-api/dev_guide/topics/languages.html.\n\nNote: If the first language in the list is not supported, an info notification will be generated with code `mainLanguageNotFound`.\n",
        "example": "zh-tw,en-gb,en-us",
        "explode": false,
        "in": "query",
        "name": "lang",
        "schema": {
          "default": [
            "en-US"
          ],
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "style": "form"
      },
      "maxSpeedOnSegment": {
        "allowReserved": true,
        "description": "Specify new base speed for segment by value. Affects route selection and the ETA. Cannot increase base speed on segment.\n",
        "examples": {
          "speed": {
            "summary": "Setting new base speed on segment",
            "value": {
              "speed": "here:cm:segment:76771992#*;speed=42"
            }
          }
        },
        "in": "query",
        "name": "maxSpeedOnSegment",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/MaxSpeedOnSegment"
        },
        "style": "form"
      },
      "origin": {
        "allowReserved": true,
        "description": "A location defining the origin of the trip.\n\n## Format\n\nFormat: `Place[WaypointOptions]`\n\n* Place: `{lat},{lng}[PlaceOptions]`\n* PlaceOptions: `;option1=value1;option2=value2...`\n* WaypointOptions: `!option1=value1!option2=value2...`\n\nA waypoint consists of:\n\n* Exactly one place\n* Optional settings for the place\n* Optional settings for the waypoint itself\n\nSupported place options:\n\n* `course`: int, degrees clock-wise from north. Indicating desired direction at the place.\n  E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance`\n* `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be\n  used. E.g. if the location is to the left of the street, the router will prefer using\n  that side in case the street has dividers. E.g.\n  `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`\n  side of the street should be preferred. This option is required, if `matchSideOfStreet`\n  is set to `always`.\n* `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by\n  `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as\n  well.\n  + `always` : Always prefer the given side of street.\n  + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case\n    the street has dividers. This is the default behavior.\n* `nameHint`: string. Causes the router to look for the place with the most similar name.\n  This can e.g. include things like: `North` being used to differentiate between\n  interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly\n  select a residental street.\n* `radius`: int, meters. Asks the router to consider all places within the given radius as\n  potential candidates for route calculation. This can be either because it is not\n  important which place is used, or because it is unknown. Radius more than 200meter are\n  not supported.\n* `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.\n  For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions.\n* `customizationIndex`: int. Specifies the zero-based index into the list of customizations\n  specified in the `customizations` parameter. The customization at that index must be an\n  Extension Map.\n  Providing a `customizationIndex` indicates the this waypoint is located within that\n  Extension Map.\n  **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change.\n* `segmentIdHint`: string. Causes the router to try and match to the specified segment.\n  Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint\n  This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one.\n* `onRoadThreshold`: int, meters. allows specifying a distance within which\n  the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.\n  Within this threshold, the attributes of the segments do not impact the matching.\n  Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.\n\nNotes:\n\n* `stopDuration` option is not supported for `origin`, contrary to `destination` and\n  `via` waypoints.\n* `passThrough`: option is not supported for 'origin'.\n* Non-structural reserved characters in options' values need to be properly percent-encoded.\n  Please refer to the developers' guide for more details.\n",
        "examples": {
          "coordinate": {
            "summary": "A simple WGS84 coordinate",
            "value": "51.611571,11.351608"
          },
          "course": {
            "summary": "Setting course/radius/minCourseDistance an uncertain GPS coordinate of a moving vehicle",
            "value": "51.611571,11.351608;course=170;radius=20;minCourseDistance=500"
          },
          "name": {
            "summary": "Setting nameHint to avoid matching to the wrong location",
            "value": "52.510319,13.285616;nameHint=Kaiserdamm"
          },
          "side": {
            "summary": "Populating sideOfStreetHint in addition to location to avoid ending on the wrong side of the street",
            "value": "52.531052,13.384872;sideOfStreetHint=52.530941,13.384939;matchSideOfStreet=always"
          }
        },
        "in": "query",
        "name": "origin",
        "required": true,
        "schema": {
          "$ref": "#/components/schemas/Waypoint"
        }
      },
      "pedestrianSpeed": {
        "description": "Walking speed in meters per second. Influences the duration of walking segments along the route.\n",
        "in": "query",
        "name": "pedestrian[speed]",
        "schema": {
          "$ref": "#/components/schemas/PedestrianSpeed"
        }
      },
      "rerouting": {
        "in": "query",
        "name": "rerouting",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/Rerouting"
        },
        "style": "deepObject"
      },
      "return": {
        "description": "Defines which attributes are included in the response as part of data representation of a\n`Route` or `Section`.\n\n* `polyline` - Polyline for the route in [Flexible Polyline](https://github.com/heremaps/flexible-polyline) Encoding.\n Either a 2D polyline (without `elevation` specified), or a 3D polyline with the 3rd dimension type `Elevation` (with `elevation` specified).\n* `actions` - Actions (such as maneuvers or tasks) that must be taken to complete the section.\n* `instructions` - Include instructions in returned actions. Instructions are localized to the requested language.\n* `summary` - Include summary for the section.\n* `travelSummary` - Include summary for the travel portion of the section.\n* `turnByTurnActions` - Include all information necessary to support turn by turn guidance to complete the section.\n* `mlDuration` - Use a region-specific machine learning model to calculate route duration.\n  **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes.**\n* `typicalDuration` - Include route duration under typical traffic conditions.\n* `elevation` - Include elevation information in coordinate and geometry types. See e.g. `polyline` or `location`.\n* `routeHandle` - Encode calculated route and return a handle which can be used with\n`routes/{routeHandle}` to decode the route at a later point in time.\n* `passthrough` - Include information on passthrough via waypoints in the section.\n* `incidents` - Include a list of all incidents applicable to each section.\n   Incidents are localized to the requested language.\n   This requires `incidents` to be specified as part of the `return` parameter.\n* `routingZones` - Include information about routing zones each section goes through.\n* `truckRoadTypes` - Include information about road types each section goes through.\n* `tolls` - Include information about the tolls to be paid, per section, according to the `tolls` parameter and other toll-influencing\n  parameters such as vehicle dimensions in the query,\n  e.g `transportMode`, `vehicle[hovOccupancy]`, truck[height]. The full list of toll-related attributes is available in the\n  [Tolls](https://developer.here.com/documentation/routing-api/dev_guide/topics/use-cases/tolls.html) page of the Developer Guide\n  If tolls cannot be calculated for a section, it will contain the `tollsDataUnavailable` notice code.\n  **Note**: some toll-related options such as cars with trailers, or vehicle fuel related tolls are planned but not implemented at the moment.\n  Therefore the request will return the most \"typical\" toll cost.\n\nThe following restrictions apply when specifying the `return` parameter:\n\n* If `actions` is requested, then `polyline` must also be requested as well.\n* If `instructions` is requested, then `actions` must also be requested as well.\n* If `turnByTurnActions` is requested, then `polyline` must also be requested as well.\n* If at least one attribute is requested within the `spans` parameter, then `polyline` must be request as well\n",
        "explode": false,
        "in": "query",
        "name": "return",
        "schema": {
          "items": {
            "$ref": "#/components/schemas/Return"
          },
          "type": "array",
          "uniqueItems": true
        },
        "style": "form"
      },
      "routeHandle": {
        "description": "Route handle returned from a previous route calculation.\n\nSee `return` parameter of `/routes` endpoint for more information.\n",
        "in": "path",
        "name": "routeHandle",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "routeHandleOrigin": {
        "allowReserved": true,
        "description": "A location defining the origin of the trip. The origin has to be located along the\npreviously calculated route.\n\n## Format\n\nFormat: `Place[WaypointOptions]`\n\n* Place: `{lat},{lng}[PlaceOptions]`\n* PlaceOptions: `;option1=value1;option2=value2...`\n* WaypointOptions: `!option1=value1!option2=value2...`\n\nA waypoint consists of:\n\n* Exactly one place\n* Optional settings for the place\n* Optional settings for the waypoint itself\n\nSupported place options:\n\n* `course`: int, degrees clock-wise from north. Indicating desired direction at the place.\n  E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance`\n* `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be\n  used. E.g. if the location is to the left of the street, the router will prefer using\n  that side in case the street has dividers. E.g.\n  `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`\n  side of the street should be preferred. This option is required, if `matchSideOfStreet`\n  is set to `always`.\n* `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by\n  `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as\n  well.\n  + `always` : Always prefer the given side of street.\n  + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case\n    the street has dividers. This is the default behavior.\n* `nameHint`: string. Causes the router to look for the place with the most similar name.\n  This can e.g. include things like: `North` being used to differentiate between\n  interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly\n  select a residental street.\n* `radius`: int, meters. Asks the router to consider all places within the given radius as\n  potential candidates for route calculation. This can be either because it is not\n  important which place is used, or because it is unknown. Radius more than 200meter are\n  not supported.\n\nNotes:\n\n* `stopDuration` option is not supported for `origin`, contrary to `destination` and\n  `via` waypoints.\n* `passThrough`: option is not supported for 'origin'.\n* Non-structural reserved characters in options' values need to be properly percent-encoded.\n  Please refer to the developers' guide for more details.\n* `minCourseDistance`: While this parameter can be provided for compatibility reasons,\n  it will not affect the result of a getRoutesByHandle request.\n",
        "examples": {
          "coordinate": {
            "summary": "A simple WGS84 coordinate",
            "value": "51.611571,11.351608"
          },
          "course": {
            "summary": "Setting course/radius an uncertain GPS coordinate of a moving vehicle",
            "value": "51.611571,11.351608;course=170;radius=20"
          },
          "name": {
            "summary": "Setting nameHint to avoid matching to the wrong location",
            "value": "52.510319,13.285616;nameHint=Kaiserdamm"
          },
          "side": {
            "summary": "Populating sideOfStreetHint in addition to location to avoid ending on the wrong side of the street",
            "value": "52.531052,13.384872;sideOfStreetHint=52.530941,13.384939;matchSideOfStreet=always"
          }
        },
        "in": "query",
        "name": "origin",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/Waypoint"
        }
      },
      "routingMode": {
        "description": "Specifies which optimization is applied during route calculation.\n\n* `fast`: Route calculation from start to destination optimized by travel time. In many\n  cases, the route returned by the `fast` mode may not be the route with the fastest\n  possible travel time. For example, the routing service may favor a route that remains on\n  a highway, even if a faster travel time can be achieved by taking a detour or shortcut\n  through an inconvenient side road.\n* `short`: Route calculation from start to destination disregarding any speed information.\n  In this mode, the distance of the route is minimized, while keeping the route sensible.\n  This includes, for example, penalizing turns. Because of that, the resulting route will\n  not necessarily be the one with minimal distance.\n\nNotes:\n* The following Transport modes only support `fast` routingMode\n  - `bicycle`\n  - `bus`\n  - `pedestrian`\n  - `privateBus`\n  - `scooter`\n  - `taxi`\n",
        "in": "query",
        "name": "routingMode",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/RoutingMode"
        }
      },
      "scooter": {
        "description": "Scooter specific parameters.\n  * `allowHighway`: Specifies whether scooter is allowed on highway or not. This parameter is optional.\n    If not provided, then by default scooter is not allowed to use highway.\n    There is a similar parameter avoid[features]=controlledAccessHighway to disallow highway usage.\n    avoid[features] takes precedence so if this parameter is also used then scooters are not allowed\n    to use highways even if `allowHighway` is used with value as true.\n    Possible values:\n      * `true`: scooter is allowed to use highway.\n      * `false`: scooter is not allowed to use highway.\n",
        "explode": true,
        "in": "query",
        "name": "scooter",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/Scooter"
        },
        "style": "deepObject"
      },
      "spans": {
        "description": "Defines which map content attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response.\nFor more information about the `countryCode` field, see https://www.iso.org/obp/ui/#search.\n\nThis parameter also requires that the `polyline` option is set within the `return` parameter.\n\n**NOTE:** Attribute speedLimit is deprecated, use maxSpeed instead. Attribute segmentId is deprecated, use segmentRef instead.\n",
        "explode": false,
        "in": "query",
        "name": "spans",
        "required": false,
        "schema": {
          "items": {
            "$ref": "#/components/schemas/Spans"
          },
          "type": "array",
          "uniqueItems": true
        },
        "style": "form"
      },
      "taxi": {
        "description": "Taxi specific parameters.\n  * `allowDriveThroughTaxiRoads`: Specifies if a vehicle is allowed to drive through\n    taxi-only roads and lanes. Even if this option is set to false, the vehicle is still\n    allowed on taxi-only roads at the start of the route and at the destination.\n\n    **Disclaimer**: This parameter is currently provided as Beta with limited functionality.\n",
        "explode": true,
        "in": "query",
        "name": "taxi",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/Taxi"
        },
        "style": "deepObject"
      },
      "tolls": {
        "description": "Defines properties which control toll calculation and reporting in the response.\n",
        "in": "query",
        "name": "tolls",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/Tolls"
        },
        "style": "deepObject"
      },
      "traffic": {
        "description": "Traffic specific parameters.",
        "explode": true,
        "in": "query",
        "name": "traffic",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/Traffic"
        },
        "style": "deepObject"
      },
      "transportMode": {
        "description": "Mode of transport to be used for the calculation of the route.\n\nNote:\n`bicycle`, `bus`, `privateBus`, and `taxi` modes are currently provided as Beta, with limited functionality.\nPlease refer to the developers' guide for more details.\n",
        "in": "query",
        "name": "transportMode",
        "required": true,
        "schema": {
          "$ref": "#/components/schemas/RouterMode"
        }
      },
      "truck": {
        "deprecated": true,
        "description": "Truck specific parameters. **Note** truck parameters are deprecated, use vehicle parameters\ninstead. Truck parameters cannot be used together with the vehicle parameters.\n  * `shippedHazardousGoods`:\n    Comma-separated list of shipped hazardous goods in the vehicle.\n    Possible values are:\n    * `explosive`: Explosive material\n    * `gas`: Gas\n    * `flammable`: Flammable material\n    * `combustible`: Combustible material\n    * `organic`: Organic material\n    * `poison`: Poison\n    * `radioactive`: Radioactive material\n    * `corrosive`: Corrosive material\n    * `poisonousInhalation`: Materials that are poisonous upon inhalation\n    * `harmfulToWater`: Materials that are harmful to water\n    * `other`: Other types of hazardous materials\n  * `grossWeight`: Vehicle weight including trailers and shipped goods, in kilograms.\n  * `weightPerAxle`: Vehicle weight per axle, in kilograms.\n  * `weightPerAxleGroup`: Weight of different axle groups like single and tandem axles, in kilograms.\n  * `height`: Vehicle height, in centimeters.\n  * `width`: Vehicle width, in centimeters.\n  * `length`: Vehicle length, in centimeters.\n  * `tunnelCategory`: Specifies the tunnel category used to restrict transport of specific goods.\n    Possible values:\n      * `B`\n      * `C`\n      * `D`\n      * `E`\n  * `axleCount`: Defines total number of axles in the vehicle.\n  * `type`: Specifies the type of truck\n      * `straight`: a truck on a single frame with a permanently attached cargo area\n      * `tractor`: a towing vehicle that can pull one or more semi-trailers (aka semi-truck)\n  * `trailerCount`: Number of trailers attached to the vehicle.\n",
        "explode": true,
        "in": "query",
        "name": "truck",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/Truck"
        },
        "style": "deepObject"
      },
      "units": {
        "description": "Units of measurement used in guidance instructions. The default is `metric`.\n",
        "in": "query",
        "name": "units",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/Units"
        }
      },
      "vehicle": {
        "description": "Vehicle specific parameters.\n  * `shippedHazardousGoods`:\n    Comma-separated list of shipped hazardous goods in the vehicle.\n    Possible values are:\n    * `explosive`: Explosive material\n    * `gas`: Gas\n    * `flammable`: Flammable material\n    * `combustible`: Combustible material\n    * `organic`: Organic material\n    * `poison`: Poison\n    * `radioactive`: Radioactive material\n    * `corrosive`: Corrosive material\n    * `poisonousInhalation`: Materials that are poisonous upon inhalation\n    * `harmfulToWater`: Materials that are harmful to water\n    * `other`: Other types of hazardous materials\n  * `grossWeight`: Vehicle weight including trailers and shipped goods, in kilograms.\n  * `weightPerAxle`: Vehicle weight per axle, in kilograms.\n  * `weightPerAxleGroup`: Weight of different axle groups like single and tandem axles, in kilograms.\n  * `height`: Vehicle height, in centimeters.\n  * `width`: Vehicle width, in centimeters.\n  * `length`: Vehicle length, in centimeters.\n  * `tunnelCategory`: Specifies the tunnel category used to restrict transport of specific goods.\n    Possible values:\n      * `B`\n      * `C`\n      * `D`\n      * `E`\n  * `axleCount`: Defines total number of axles in the vehicle.\n  * `type`: Specifies the type of vehicle\n      * `straightTruck`: a truck on a single frame with a permanently attached cargo area. Only\n      applicable when the truck routing mode is used.\n      * `tractor`: a towing vehicle that can pull one or more semi-trailers (aka semi-truck).\n      Only applicable when the truck routing mode is used.\n  * `trailerCount`: Number of trailers attached to the vehicle.\n",
        "explode": true,
        "in": "query",
        "name": "vehicle",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/Vehicle"
        },
        "style": "deepObject"
      },
      "via": {
        "allowReserved": true,
        "description": "A location defining a via waypoint.\n\nA via waypoint is a location between origin and destination. The route will do a stop\nat the via waypoint.\n\nMultiple waypoints can also be specified using multiple via parameters like\n`via=...&via=...`, in which case the route will traverse these waypoints sequentially in\nthe order specified in the request.\n\n## Format\n\nFormat: `Place[WaypointOptions]`\n\n* Place: `{lat},{lng}[PlaceOptions]`\n* PlaceOptions: `;option1=value1;option2=value2...`\n* WaypointOptions: `!option1=value1!option2=value2...`\n\nA waypoint consists of:\n\n* Exactly one place\n* Optional settings for the place\n* Optional settings for the waypoint itself\n\nSupported place options:\n\n* `course`: int, degrees clock-wise from north. Indicating desired direction at the place.\n  E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance`\n* `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be\n  used. E.g. if the location is to the left of the street, the router will prefer using\n  that side in case the street has dividers. E.g.\n  `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`\n  side of the street should be preferred. This option is required, if `matchSideOfStreet`\n  is set to `always`.\n* `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by\n  `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as\n  well.\n  + `always` : Always prefer the given side of street.\n  + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case\n    the street has dividers. This is the default behavior.\n* `nameHint`: string. Causes the router to look for the place with the most similar name.\n  This can e.g. include things like: `North` being used to differentiate between\n  interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly\n  select a residental street.\n* `radius`: int, meters. Asks the router to consider all places within the given radius as\n  potential candidates for route calculation. This can be either because it is not\n  important which place is used, or because it is unknown. Radius more than 200meter are\n  not supported.\n* `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.\n  For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions.\n* `customizationIndex`: int. Specifies the zero-based index into the list of customizations\n  specified in the `customizations` parameter. The customization at that index must be an\n  Extension Map.\n  Providing a `customizationIndex` indicates the this waypoint is located within that\n  Extension Map.\n  **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change.\n* `segmentIdHint`: string. Causes the router to try and match to the specified segment.\n  Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint\n  This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one.\n* `onRoadThreshold`: int, meters. allows specifying a distance within which\n  the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.\n  Within this threshold, the attributes of the segments do not impact the matching.\n  Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.\n\nSupported waypoint options:\n* `stopDuration`: desired duration for the stop, in seconds.\n* `passThrough`: boolean. Asks the router to avoid the following during route calculation:\n  + Introducing a stop at the waypoint.\n  + Splitting the route into sections.\n  + Changing the direction of travel.\n\n  Following scenarios are not supported for `passThrough` parameter:\n  + Setting both `stopDuration` to a value greater than 0 and `passThrough=true`.\n  + Setting `passThrough=true` for `origin` or `destination` of a route.\n  The default value is `false`.\n\nNotes:\n\n* Non-structural reserved characters in options' values need to be properly percent-encoded.\n  Please refer to the developers' guide for more details.\n",
        "examples": {
          "coordinate": {
            "summary": "A simple WGS84 coordinate",
            "value": "51.611571,11.351608"
          },
          "course": {
            "summary": "Setting course/radius/minCourseDistance an uncertain GPS coordinate of a moving vehicle",
            "value": "51.611571,11.351608;course=170;radius=20;minCourseDistance=500"
          },
          "duration": {
            "summary": "Addition a stopDuration for an intermediate stop",
            "value": "51.611571,11.351608!stopDuration=600"
          },
          "name": {
            "summary": "Setting nameHint to avoid matching to the wrong location",
            "value": "52.510319,13.285616;nameHint=Kaiserdamm"
          },
          "pass-through": {
            "summary": "Setting pass-through parameter to avoid possibly making a u-turn for a stop",
            "value": "51.611571,11.351608!passThrough=true"
          },
          "side": {
            "summary": "Populating sideOfStreetHint in addition to location to avoid ending on the wrong side of the street",
            "value": "52.531052,13.384872;sideOfStreetHint=52.530941,13.384939;matchSideOfStreet=always"
          }
        },
        "explode": true,
        "in": "query",
        "name": "via",
        "required": false,
        "schema": {
          "items": {
            "$ref": "#/components/schemas/Waypoint"
          },
          "type": "array"
        },
        "style": "form"
      },
      "xRequestId": {
        "description": "User-provided token that can be used to trace a request or a group of requests sent to the service.",
        "in": "header",
        "name": "X-Request-ID",
        "schema": {
          "type": "string"
        }
      }
    },
    "responses": {
      "401ErrorResponseWithRequestID": {
        "content": {
          "application/json": {
            "examples": {
              "errorResponseExample": {
                "$ref": "#/components/examples/401errorResponseExample"
              }
            },
            "schema": {
              "$ref": "#/components/schemas/AuthErrorResponseSchema"
            }
          }
        },
        "description": "API response in case of unauthorized access.",
        "headers": {
          "X-Request-Id": {
            "$ref": "#/components/headers/X-Request-Id"
          }
        }
      },
      "500ErrorResponseWithRequestID": {
        "content": {
          "application/json": {
            "examples": {
              "errorResponseExample": {
                "$ref": "#/components/examples/500errorResponseExample"
              }
            },
            "schema": {
              "$ref": "#/components/schemas/ErrorResponse"
            }
          }
        },
        "description": "API response in case of internal server error.",
        "headers": {
          "X-Correlation-Id": {
            "$ref": "#/components/headers/X-Correlation-Id"
          },
          "X-Request-Id": {
            "$ref": "#/components/headers/X-Request-Id"
          }
        }
      },
      "502ErrorResponseWithRequestID": {
        "content": {
          "application/json": {
            "examples": {
              "errorResponseExample": {
                "$ref": "#/components/examples/502errorResponseExample"
              }
            },
            "schema": {
              "$ref": "#/components/schemas/ErrorResponse"
            }
          }
        },
        "description": "API response in case of bad gateway.",
        "headers": {
          "X-Correlation-Id": {
            "$ref": "#/components/headers/X-Correlation-Id"
          },
          "X-Request-Id": {
            "$ref": "#/components/headers/X-Request-Id"
          }
        }
      },
      "503ErrorResponseWithRequestID": {
        "content": {
          "application/json": {
            "examples": {
              "errorResponseExample": {
                "$ref": "#/components/examples/503errorResponseExample"
              }
            },
            "schema": {
              "$ref": "#/components/schemas/ErrorResponse"
            }
          }
        },
        "description": "API response in case of service unavailable.",
        "headers": {
          "X-Correlation-Id": {
            "$ref": "#/components/headers/X-Correlation-Id"
          },
          "X-Request-Id": {
            "$ref": "#/components/headers/X-Request-Id"
          }
        }
      },
      "504ErrorResponseWithRequestID": {
        "content": {
          "application/json": {
            "examples": {
              "errorResponseExample": {
                "$ref": "#/components/examples/504errorResponseExample"
              }
            },
            "schema": {
              "$ref": "#/components/schemas/ErrorResponse"
            }
          }
        },
        "description": "API response in case of gateway timeout.",
        "headers": {
          "X-Correlation-Id": {
            "$ref": "#/components/headers/X-Correlation-Id"
          },
          "X-Request-Id": {
            "$ref": "#/components/headers/X-Request-Id"
          }
        }
      },
      "HealthResponseFailWithRequestID": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/HealthResponseFailSchema"
            }
          },
          "text/plain": {}
        },
        "description": "API response in case of failure.",
        "headers": {
          "X-Correlation-Id": {
            "$ref": "#/components/headers/X-Correlation-Id"
          },
          "X-Request-Id": {
            "$ref": "#/components/headers/X-Request-Id"
          }
        }
      },
      "HealthResponseOkWithRequestID": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/HealthResponseOKSchema"
            }
          }
        },
        "description": "API response in case of success.",
        "headers": {
          "X-Correlation-Id": {
            "$ref": "#/components/headers/X-Correlation-Id"
          },
          "X-Request-Id": {
            "$ref": "#/components/headers/X-Request-Id"
          }
        }
      },
      "InternalServerErrorRoutesResponse": {
        "content": {
          "application/json": {
            "examples": {
              "errorResponseExample": {
                "$ref": "#/components/examples/500RoutingErrorResponseExample"
              }
            },
            "schema": {
              "$ref": "#/components/schemas/RoutingErrorResponse"
            }
          }
        },
        "description": "Internal server error",
        "headers": {
          "X-Correlation-Id": {
            "$ref": "#/components/headers/X-Correlation-Id"
          },
          "X-Request-Id": {
            "$ref": "#/components/headers/X-Request-Id"
          }
        }
      },
      "InvalidRoutesRequestResponse": {
        "content": {
          "application/json": {
            "examples": {
              "errorResponseExample": {
                "$ref": "#/components/examples/400RoutingErrorResponseExample"
              }
            },
            "schema": {
              "$ref": "#/components/schemas/RoutingErrorResponse"
            }
          }
        },
        "description": "Failure to parse the request, caused by, for example, invalid parameter values such as\n`transportMode=spaceShuttle` or `alternatives=999`.\n\nNote that route calculation errors aren't considered failures. Cf. `RouterRouteResponse`\nfor details on route calculation errors.\n",
        "headers": {
          "X-Correlation-Id": {
            "$ref": "#/components/headers/X-Correlation-Id"
          },
          "X-Request-Id": {
            "$ref": "#/components/headers/X-Request-Id"
          }
        }
      },
      "RoutesResponseOk": {
        "content": {
          "application/json": {
            "examples": {
              "routeResponseExample": {
                "$ref": "#/components/examples/routeResponseExample"
              }
            },
            "schema": {
              "$ref": "#/components/schemas/RouterRouteResponse"
            }
          }
        },
        "description": "Routes API response in case of success",
        "headers": {
          "X-Correlation-Id": {
            "$ref": "#/components/headers/X-Correlation-Id"
          },
          "X-Request-Id": {
            "$ref": "#/components/headers/X-Request-Id"
          }
        }
      },
      "Routing403ErrorResponse": {
        "content": {
          "application/json": {
            "examples": {
              "errorResponseExample": {
                "$ref": "#/components/examples/403RoutingErrorResponseExample"
              }
            },
            "schema": {
              "$ref": "#/components/schemas/Routing403ErrorResponseSchema"
            }
          }
        },
        "description": "Not allowed, such as trying to calculate routes in Japan without having necessary\npermissions.\n",
        "headers": {
          "X-Correlation-Id": {
            "$ref": "#/components/headers/X-Correlation-Id"
          },
          "X-Request-Id": {
            "$ref": "#/components/headers/X-Request-Id"
          }
        }
      },
      "VersionResponseOkWithRequestID": {
        "content": {
          "application/json": {
            "examples": {
              "versionResponseOkExample": {
                "$ref": "#/components/examples/VersionResponseOkExample"
              }
            },
            "schema": {
              "$ref": "#/components/schemas/VersionResponse"
            }
          }
        },
        "description": "API response in case of success.",
        "headers": {
          "X-Correlation-Id": {
            "$ref": "#/components/headers/X-Correlation-Id"
          },
          "X-Request-Id": {
            "$ref": "#/components/headers/X-Request-Id"
          }
        }
      }
    },
    "schemas": {
      "AccessAttributes": {
        "description": "Extensible enum: `open` `noThrough` `tollRoad` `...`  \n`AccessAttributes` is applied to a span of a route section and describes access flags of a street.\n\n* `open`: A part of the route that can be traversed.\n* `noThrough`: A part of the route that can only be traversed if origin, destination or any via waypoint is located there.\n* `tollRoad`: Access to this part of the route is restricted with a fee (or toll).\n\nAs it is possible that new access attributes are supported in the future, unknown access attributes should be ignored.\n",
        "type": "string",
        "x-extensible-enum": [
          "open",
          "noThrough",
          "tollRoad"
        ]
      },
      "AccessPointPlace": {
        "description": "Access point to a venue/station",
        "properties": {
          "location": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Location"
              }
            ],
            "description": "The position of this location\n\nThis position was used in route calculation. It may be different to the original position provided in the request.\n"
          },
          "name": {
            "description": "Location name",
            "type": "string"
          },
          "originalLocation": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Location"
              }
            ],
            "description": "If present, the original position of this location provided in the request."
          },
          "type": {
            "description": "Place type. Each place type can have extra attributes.\n\n**NOTE:** The list of possible place types could be extended in the future.\nThe client application is expected to handle such a case gracefully.\n",
            "type": "string"
          },
          "waypoint": {
            "description": "If present, this place corresponds to the waypoint in the request with the same index.",
            "type": "integer"
          },
          "wheelchairAccessible": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WheelchairAccessibility"
              }
            ],
            "description": "Information about accessibility for people with a disability and who use a wheelchair.\n\n* `unknown` - Accessibility information is not available.\n* `yes` - Access point is wheelchair accessible.\n* `limited` - Accessibility is limited or assistance is required.\n* `no` - No accessible path from the access point to platforms.\n"
          }
        },
        "required": [
          "type",
          "location"
        ]
      },
      "Agency": {
        "description": "Contains information about a particular agency.",
        "properties": {
          "id": {
            "description": "Unique code of the agency. Specifies if the same agency is used on different sections of the same route.",
            "type": "string"
          },
          "name": {
            "description": "Human readable name of the owner of the transport service.",
            "type": "string"
          },
          "website": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Uri"
              }
            ],
            "description": "Link to the agency's website."
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "ArriveAction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/OffsetAction"
          }
        ]
      },
      "Attribution": {
        "description": "The URL address to an external resource.",
        "properties": {
          "href": {
            "$ref": "#/components/schemas/Uri"
          },
          "hrefText": {
            "description": "The interactive (or clickable) portion of the text. If not present (default), the entire content of the text attribute will be considered.\n",
            "type": "string"
          },
          "id": {
            "description": "Unique identifier for the web link. It is used to deduplicate links defined in multiple sections.",
            "type": "string"
          },
          "text": {
            "description": "Text describing the url address (e.g. The example website).",
            "type": "string"
          },
          "type": {
            "$ref": "#/components/schemas/AttributionLinkType"
          }
        },
        "required": [
          "id",
          "text"
        ]
      },
      "AttributionLinkType": {
        "description": "Attribution link type.\n\n* `disclaimer` - Page with further legal information from the agency.\n* `tariff` - Page with information on the tariff.\n",
        "enum": [
          "disclaimer",
          "tariff"
        ],
        "required": [
          "type"
        ],
        "type": "string"
      },
      "AuthErrorResponseSchema": {
        "properties": {
          "error": {
            "description": "Human-readable error",
            "type": "string"
          },
          "error_description": {
            "description": "Human-readable error description",
            "type": "string"
          }
        }
      },
      "Avoid": {
        "properties": {
          "areas": {
            "description": "A pipe separated list of user defined areas that routes will avoid to go through.\nThe list is limited by 250 items.\n\nFormat: `{shape1}|{shape2}|{shape3}...`\n\nSupported shape format:\n* Bounding box - A rectangular area on earth defined by a comma separated list of two latitude and two longitude values.\n  - Format: `bbox:{west},{south},{east},{north}`\n    + `{west}`  - Longitude value of the westernmost point of the area.\n    + `{south}` - Latitude value of the southernmost point of the area.\n    + `{east}`  - Longitude value of the easternmost point of the area.\n    + `{north}` - Latitude value of the northernmost point of the area.\n  - Example: `bbox:13.082,52.416,13.628,52.626` - Bounding box of Berlin\n* Polygon - A polygon on earth which defines area to avoid.\n  Possible formats:\n  1) As list of geopoints.\n    - Format: `polygon:{lat},{lon};{lat},{lon};{lat},{lon}...`\n      + `{lat}` - Latitude\n      + `{lon}` - Longitude\n    - Example: `polygon:52.416,13.082;52.626,13.628;52.916,13.482` - Polygon in Berlin\n  2) As [Flexible Polyline](https://github.com/heremaps/flexible-polyline) Encoding.\n    - Support only 2D polyline (without `elevation` specified).\n    - Format: `polygon:{encoded_polyline}`\n      + `{encoded_polyline}` - encoded [Flexible Polyline](https://github.com/heremaps/flexible-polyline)\n    - Example: `polygon:BF05xgKuy2xCx9B7vUl0OhnR54EqSzpEl-HxjD3pBiGnyGi2CvwFsgD3nD4vB6e`\n  Notes:\n  * Maximal count of polygons is 20. Count of bounding boxes + polygons <= 250\n  * Minimal count of coordinates in one polygon is 3. If less - corresponding error will be returned.\n  * Maximal count of coordinates in one polygon is 16. If more - corresponding error will be returned.\n  * The polygon is closed automatically, there is no need to duplicate the first point as the last one.\n  * Self-intersecting polygons are not supported. If they are present in the request, the corresponding error will be returned.\n",
            "type": "string"
          },
          "features": {
            "description": "A comma separated list of features that routes will avoid.\n\n* `seasonalClosure`\n* `tollRoad`\n* `controlledAccessHighway`\n* `ferry`\n* `carShuttleTrain`\n* `tunnel`\n* `dirtRoad`\n* `difficultTurns`: This option avoids difficult turns, sharp turns and U-turns on highways and motorways. It is only supported for the `truck` transport mode.\n* `uTurns`: This option avoids U-turns on highways and motorways. It is not supported for pedestrian, bicycle and scooter transport modes.\n",
            "type": "string"
          },
          "segments": {
            "description": "A comma separated list of segment identifiers that routes will avoid going through.\n\nEach entry has the following structure:\n`{segmentId}(#{direction})?`\n\nThe individual parts are:\n* segmentId: The identifier of the referenced topology segment inside the catalog, example: `here:cm:segment:207551710`\n* direction (optional): Either '*' for bidirectional (default), '+' for positive direction, or '-' for negative direction\n\nExample of a parameter value excluding two segments:\n`here:cm:segment:207551710#+,here:cm:segment:76771992#*`\n\n**Note**: Maximum amount of penalized segments in one request should not be grater than 250.\n          \"Penalized segments\" refers to segments that have a restriction on maximum baseSpeed with `maxSpeedOnSegment`\n          or avoided with `avoid[segments]`\n",
            "type": "string"
          },
          "tollTransponders": {
            "description": "Indicates that routes will avoid all toll transponders.\n\nExample: `avoid[tollTransponders]=all`\n",
            "type": "string"
          },
          "truckRoadTypes": {
            "description": "A comma-separated list of truck road type identifiers to be avoided.\n\nA truck road type is an identifier associated with roads that have additional regulations applied by local administration for traversal by heavy vehicles like trucks.\nFor example, the BK Bearing Class regulations in Sweden, and ET categories in Mexico.\nIdentifiers for supported truck road types are specified at HERE Map Content\n[TruckRoadType](https://developer.here.com/documentation/here-map-content/dev_guide/topics_schema/truckroadtypeattribute.truckroadtype.html).\n\nExample: `avoid[truckRoadTypes]=BK1,BK2,BK3,BK4`\n",
            "example": "BK1,BK2,BK3,BK4",
            "type": "string"
          },
          "zoneCategories": {
            "description": "Specifies a list of categories of zones which routes will avoid going through.\n\nFormat: `Categories[ZoneCategoryOptions]`\n\n* Categories: `{cat1},{cat2}...`\n  A comma separated list of zone categories.\n* ZoneCategoriesOptions (optional): `;option1=value1;options2=value2...`\n  A list of options for zone categories in `KEY=VALUE` form.\n\nSupported zone category options:\n  * exceptZoneIds: A comma-separated list of zone identifiers, which will not be taken into account for evaluation of zone categories to avoid.\n\nSupported zone categories:\n  * `vignette`\n  * `congestionPricing`\n  * `environmental`\n\nExample of zone categories avoidance:\n`avoid[zoneCategories]=environmental,vignette`\n\nExample of zone categories avoidance with exceptions:\n`avoid[zoneCategories]=environmental,vignette;exceptZoneIds=here:cm:envzone:3`\n",
            "type": "string"
          },
          "zoneIdentifiers": {
            "description": "A comma separated list containing identifiers of zones that routes will avoid going through.\n\nExample of an identifier referencing an environmental zone:\n`here:cm:envzone:2`\n",
            "type": "string"
          }
        },
        "type": "object"
      },
      "AvoidPost": {
        "description": "Avoid routes that violate certain features of road network or that go through\nuser-specified geographical bounding boxes.\n\nFor the general description of the functionality please refer to the `avoid` parameter of the\nquery string.\n\nPassing parameters in the POST body is suggested when the length of the parameters exceeds the\nlimitation of the GET request.\n",
        "properties": {
          "segments": {
            "description": "An array of segment identifiers that routes will avoid going through.\n\nEach entry has the following structure:\n`{segmentId}(#{direction})?`\n\nThe individual parts are:\n* segmentId: The identifier of the referenced topology segment inside the catalog, example: `here:cm:segment:207551710`\n* direction (optional): Either '*' for bidirectional (default), '+' for positive direction, or '-' for negative direction\n\nExample of a parameter value excluding two segments:\n`[\"here:cm:segment:207551710#+\", \"here:cm:segment:76771992#*\"]`\n\n**Note**: Maximum amount of penalized segments in one request should not be grater than 250.\n          \"Penalized segments\" refers to segments that have a restriction on maximum baseSpeed with `maxSpeedOnSegment`\n          or avoided with `avoid[segments]`\n",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "BaseAction": {
        "description": "An action to be performed between sections or during a section.",
        "properties": {
          "action": {
            "description": "The type of the action.\n\n**NOTE:** The list of possible actions may be extended in the future. The client application should handle such a case gracefully.\n",
            "type": "string"
          },
          "duration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "Estimated duration of this action (in seconds). Actions last until the next action, or the end of the route in case of the last one."
          },
          "instruction": {
            "description": "Description of the action (e.g. Turn left onto Minna St.).",
            "type": "string"
          }
        },
        "required": [
          "action",
          "duration"
        ]
      },
      "BaseNoticeDetail": {
        "properties": {
          "cause": {
            "description": "Cause of the notice",
            "type": "string"
          },
          "title": {
            "description": "Detail title",
            "type": "string"
          },
          "type": {
            "description": "Detail type. Each type of detail might contain extra attributes.\n\n**NOTE:** The list of possible detail types may be extended in the future.\nThe client application is expected to handle such a case gracefully.\n",
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "BasePlace": {
        "properties": {
          "location": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Location"
              }
            ],
            "description": "The position of this location\n\nThis position was used in route calculation. It may be different to the original position provided in the request.\n"
          },
          "name": {
            "description": "Location name",
            "type": "string"
          },
          "originalLocation": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Location"
              }
            ],
            "description": "If present, the original position of this location provided in the request."
          },
          "type": {
            "description": "Place type. Each place type can have extra attributes.\n\n**NOTE:** The list of possible place types could be extended in the future.\nThe client application is expected to handle such a case gracefully.\n",
            "type": "string"
          },
          "waypoint": {
            "description": "If present, this place corresponds to the waypoint in the request with the same index.",
            "type": "integer"
          }
        },
        "required": [
          "type",
          "location"
        ]
      },
      "BaseSummary": {
        "description": "Total value of key attributes for a route section.",
        "properties": {
          "duration": {
            "$ref": "#/components/schemas/Duration"
          },
          "length": {
            "$ref": "#/components/schemas/Distance"
          }
        },
        "required": [
          "duration",
          "length"
        ]
      },
      "BoardAction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseAction"
          }
        ],
        "description": "An action to board a ferry."
      },
      "CalculateRoutesPostParameters": {
        "description": "Parameters of the POST body for route calculation",
        "example": {
          "$ref": "#/components/examples/calculateRoutesPostParametersExample"
        },
        "properties": {
          "avoid": {
            "$ref": "#/components/schemas/AvoidPost"
          },
          "ev": {
            "$ref": "#/components/schemas/EVPost"
          },
          "maxSpeedOnSegment": {
            "$ref": "#/components/schemas/MaxSpeedOnSegmentPost"
          }
        },
        "type": "object"
      },
      "ChargingAction": {
        "description": "An action to charge the vehicle.\n",
        "properties": {
          "action": {
            "description": "The type of the action.\n\n**NOTE:** The list of possible actions may be extended in the future. The client application should handle such a case gracefully.\n",
            "type": "string"
          },
          "arrivalCharge": {
            "description": "Estimated vehicle battery charge before this action (in kWh).\n",
            "type": "number"
          },
          "consumablePower": {
            "description": "Maximum charging power (in kW) available to the vehicle, based on the properties of the charging\nstation and the vehicle.\n",
            "type": "number"
          },
          "duration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "Estimated duration of this action (in seconds). Actions last until the next action, or the end of the route in case of the last one."
          },
          "instruction": {
            "description": "Description of the action (e.g. Turn left onto Minna St.).",
            "type": "string"
          },
          "targetCharge": {
            "description": "Level to which vehicle battery should be charged by this action (in kWh).\n",
            "type": "number"
          }
        },
        "required": [
          "action",
          "duration"
        ]
      },
      "ChargingConnectorAttributes": {
        "description": "Details of the connector that is suggested to be used in the section's `postAction` for charging.",
        "properties": {
          "connectorType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChargingConnectorType"
              }
            ],
            "description": "Suggested connector for charging at this station"
          },
          "current": {
            "description": "Current of the suggested connector in Amperes.",
            "type": "number"
          },
          "power": {
            "description": "Power supplied by the suggested connector in kW.",
            "type": "number"
          },
          "supplyType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChargingSupplyType"
              }
            ],
            "description": "Supply type of the suggested connector.\n"
          },
          "voltage": {
            "description": "Voltage of the suggested connector in Volts.",
            "type": "number"
          }
        },
        "required": [
          "power",
          "supplyType",
          "connectorType"
        ]
      },
      "ChargingConnectorType": {
        "description": "Extensible enum: `iec62196Type1Combo` `iec62196Type2Combo` `chademo` `tesla` `...`  \nCurrently supported connector types are:\n* `iec62196Type1Combo`:  Type 1 Combo connector, commonly called \"SAE J1772\"\n* `iec62196Type2Combo`:  Type 2 Combo connector, commonly called \"Mennekes\"\n* `chademo`: CHAdeMO connector\n* `tesla`: Tesla connector\n",
        "type": "string",
        "x-extensible-enum": [
          "iec62196Type1Combo",
          "iec62196Type2Combo",
          "chademo",
          "tesla"
        ]
      },
      "ChargingSetupAction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseAction"
          }
        ],
        "description": "An action to prepare for vehicle charging. Represents the time spent setting up for charging (e.g., payment processing), independent\nof the time required to actually charge the vehicle.\n"
      },
      "ChargingStationBrand": {
        "description": "Information regarding the charging station brand",
        "properties": {
          "hrn": {
            "description": "Charging station brand unique ID.\nIf specified in `ev[preferredBrands]` parameter\nthen it would apply preference to adding stations of the given brand.\n\n**NOTE:** As of now it is generated as a brand name hash.\nIt will be changed to HRN (HERE Resource Name) in the future.\n",
            "type": "string"
          },
          "name": {
            "description": "Charging station brand name",
            "type": "string"
          }
        }
      },
      "ChargingStationPlace": {
        "description": "A charging station",
        "properties": {
          "brand": {
            "$ref": "#/components/schemas/ChargingStationBrand"
          },
          "connectorAttributes": {
            "$ref": "#/components/schemas/ChargingConnectorAttributes"
          },
          "id": {
            "description": "Identifier of this charging station",
            "type": "string"
          },
          "location": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Location"
              }
            ],
            "description": "The position of this location\n\nThis position was used in route calculation. It may be different to the original position provided in the request.\n"
          },
          "name": {
            "description": "Human readable name of this charging station",
            "type": "string"
          },
          "originalLocation": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Location"
              }
            ],
            "description": "If present, the original position of this location provided in the request."
          },
          "type": {
            "description": "Place type. Each place type can have extra attributes.\n\n**NOTE:** The list of possible place types could be extended in the future.\nThe client application is expected to handle such a case gracefully.\n",
            "type": "string"
          },
          "waypoint": {
            "description": "If present, this place corresponds to the waypoint in the request with the same index.",
            "type": "integer"
          }
        },
        "required": [
          "type",
          "location"
        ]
      },
      "ChargingSupplyType": {
        "description": "Extensible enum: `acSingle` `acThree` `dc` `...`  \nCurrently possible values are:\n\n* `acSingle` : Single phase Alternating Current supply\n* `acThree`: Three phase Alternating Current supply\n* `dc`: Direct Current supply\n",
        "type": "string",
        "x-extensible-enum": [
          "acSingle",
          "acThree",
          "dc"
        ]
      },
      "Color": {
        "example": "#FF0000",
        "pattern": "#[0-9A-Fa-f]{6}",
        "type": "string"
      },
      "ConsumptionSpeedTable": {
        "description": "Function curve specifying consumption rate at a given speed.\n\nThe format of the string is a comma-separated list of numbers, as follows:\n\n```\n<SPEED_0>,<CONSUMPTION_0>,<SPEED_1>,<CONSUMPTION_1>,...,<SPEED_N>,<CONSUMPTION_N>\n```\n\nwhere speed values are strictly increasing, non-negative integers in units of (km/h), and\nconsumption values are non-negative floating point values in units of (Wh/m).\n\nThe function is linearly interpolated between data points. For speeds less than `SPEED_0`\nthe value of the function is `CONSUMPTION_0`, and for speeds greater than `SPEED_N` the\nvalue of the function is `CONSUMPTION_N`.\n",
        "example": "0,0.2394,14,0.2394,36,0.2586,52,0.196,68,0.2074,83,0.238,95,0.2597,105,0.2597,115,0.2964,125,0.3367,135,0.3508",
        "type": "string"
      },
      "ContinueAction": {
        "description": "An action to be performed at or during a specific portion of a section.\n\n* `depart`: departure maneuver, such as \"Start at\"\n* `arrive`: arrival maneuver, such as \"Arrive at\"\n* `continue`: continue maneuver, such as \"Continue on\"\n",
        "properties": {
          "action": {
            "description": "The type of the action.\n\n**NOTE:** The list of possible actions may be extended in the future. The client application should handle such a case gracefully.\n",
            "type": "string"
          },
          "currentRoad": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RoadInfo"
              }
            ],
            "description": "Attributes of the current road"
          },
          "duration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "Estimated duration of this action (in seconds). Actions last until the next action, or the end of the route in case of the last one."
          },
          "exitSign": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ExitInfo"
              }
            ],
            "description": "Attributes of the road exit"
          },
          "instruction": {
            "description": "Description of the action (e.g. Turn left onto Minna St.).",
            "type": "string"
          },
          "intersectionName": {
            "description": "Name of the intersection where the turn takes place, if available.",
            "items": {
              "$ref": "#/components/schemas/LocalizedString"
            },
            "type": "array"
          },
          "length": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Distance"
              }
            ],
            "description": "Estimated length of this action (in meters). Actions extend until the next action, or the end of the route in case of the last one."
          },
          "nextRoad": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RoadInfo"
              }
            ],
            "description": "Attributes of the next road"
          },
          "offset": {
            "description": "Offset of a coordinate in the section's polyline.",
            "type": "integer"
          }
        },
        "required": [
          "action",
          "duration"
        ]
      },
      "CountryCode": {
        "description": "ISO-3166-1 alpha-3 code",
        "example": "FRA",
        "type": "string"
      },
      "CustomizationHRN": {
        "description": "HERE Resource Name identifier for customization. This HRN must follow a convention below: hrn:here:<service_id>::<customer-realm-id>:custom:<customization_type>:<customization_id>.",
        "example": "hrn:here:routing::olp-abc:custom:extension-map:abc-yard-routing",
        "pattern": "^hrn:here:[a-z]+::[a-z|-]+:custom:[a-z|-]+$",
        "type": "string"
      },
      "DataVersion": {
        "description": "Version of a specific data set",
        "properties": {
          "name": {
            "description": "Identifies a data set, for example, a HRN, or a service specific identifier",
            "type": "string"
          },
          "version": {
            "description": "The current version of this data set",
            "type": "string"
          }
        },
        "required": [
          "name",
          "version"
        ]
      },
      "DeboardAction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseAction"
          }
        ],
        "description": "An action to disembark a ferry."
      },
      "DepartAction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/OffsetAction"
          }
        ]
      },
      "DepartureDelay": {
        "description": "The accumulated delay in seconds from the scheduled time of the event.",
        "type": "integer"
      },
      "DepartureStatus": {
        "default": "scheduled",
        "description": "Extensible enum: `scheduled` `cancelled` `additional` `replaced` `...`  \nStatus of the departure\n\n* `scheduled`: A trip that is running as planned in the schedule.\n* `cancelled`: A trip that existed in the schedule but was removed.\n* `additional`: An extra trip that was added in addition to a running schedule, for example, to respond to sudden passenger load.\n* `replaced`: A trip that was in the schedule but is removed and replaced with `additional` trip, for example, to replace a broken vehicle or handle detour.\n",
        "type": "string",
        "x-extensible-enum": [
          "scheduled",
          "cancelled",
          "additional",
          "replaced"
        ]
      },
      "Distance": {
        "description": "Distance in meters.",
        "minimum": 0,
        "type": "integer"
      },
      "DockingStationPlace": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BasePlace"
          }
        ],
        "description": "A place represents a docking station for rented vehicles."
      },
      "Duration": {
        "description": "Duration in seconds.",
        "type": "integer"
      },
      "DynamicSpeedInfo": {
        "description": "Describes dynamic speed information, such as traffic speed, estimated speed without traffic, and turn time.\n",
        "properties": {
          "baseSpeed": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Speed"
              }
            ],
            "description": "Estimated speed without considering any traffic-related constraints."
          },
          "trafficSpeed": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Speed"
              }
            ],
            "description": "Traffic-enabled speed, which is the estimated speed considering traffic-relevant constraints.\n"
          },
          "turnTime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "Turn time estimate considering traffic and transport mode needed for turning from this segment into the next.\n"
          }
        },
        "required": [
          "trafficSpeed",
          "baseSpeed",
          "turnTime"
        ]
      },
      "EV": {
        "description": "EV parameters to be used for calculating consumption and for calculating EV routes with\nautomatically added charging stations.\n\nThe following attributes are required for calculating consumption:\n* `freeFlowSpeedTable`\n* `ascent`\n* `descent`\n\nThe following attributes are additionally required in order to calculate reachable routes:\n\n* `initialCharge`\n* `maxCharge`\n* `connectorTypes`\n* `chargingCurve`\n* `maxChargeAfterChargingStation`\n* `makeReachable` set to `true`\n\nAll remaining attributes are optional.\n",
        "properties": {
          "ascent": {
            "description": "Rate of energy consumed per meter rise in elevation (in Wh/m, i.e., Watt-hours per meter).\n",
            "minimum": 0,
            "type": "number"
          },
          "auxiliaryConsumption": {
            "description": "Rate of energy (in Wh/s) consumed by the vehicle's auxiliary systems (for example, air conditioning, lights).\nThe value represents the number of Watt-hours consumed per second of travel.\n",
            "minimum": 0,
            "type": "number"
          },
          "chargingCurve": {
            "description": "Function curve describing the maximum battery charging rate (in kW) at a given charge level (in kWh).\n\nThe format of the string is a comma-separated list of numbers, as follows:\n\n```\n<CHARGE_0>,<RATE_0>,<CHARGE_1>,<RATE_1>,...,<RATE_N>,<CHARGE_N>\n```\n\nwhere charge values are strictly increasing, non-negative floating-point values in units\nof (kWh), and rate values are positive floating point values in units of (kW).\n\nCharge values must cover the entire range of `[0, maxChargeAfterChargingStation`]. The\ncharging curve is piecewise constant, e.g., for any charge in the range `[CHARGE_0,\nCHARGE_1)`, the value of the function is `RATE_0`.\n\nThe algorithm calculates a route as the best possible combination of driving and charging\nparts and uses the charging curve to evaluate the most efficent range of\ncharging. For example, if the rate of charging is high at lower levels of battery, but slows down significantly after charging a little, stopping\noften and charging less, but quicker, at each station might be better for the overall route.\nBecause batteries lose charging speed with use, providing a charging curve for the\nexact battery would give more accurate charging time estimate than providing a\ngeneric curve for all batteries of one type.\n",
            "example": "0,207,28.761,207,29.011,173,43.493,173,43.743,145,51.209,145,51.459,113,56.120,113,56.370,87,80.0,10",
            "type": "string"
          },
          "chargingSetupDuration": {
            "description": "Time spent (in seconds) after arriving at a charging station but before actually charging\n(for example, time spent for payment processing).\n",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "connectorTypes": {
            "description": "Comma-separated list of connector types that are compatible with the vehicle. If `makeReachable` is set to `true`,\nthen only stations with any of these connector types will be evaluated as a potential charging stop.\nFor stations with multiple compatible connectors, the charging time is based on the connector type with the highest power rating among them.\n\nCurrently supported connector types are:\n  * `iec62196Type1Combo`:  Type 1 Combo connector, commonly called \"SAE J1772\"\n  * `iec62196Type2Combo`:  Type 2 Combo connector, commonly called \"Mennekes\"\n  * `chademo`: CHAdeMO connector\n  * `tesla`: Tesla connector\n",
            "example": "iec62196Type1Combo,chademo",
            "type": "string"
          },
          "descent": {
            "description": "Rate of energy recovered per meter fall in elevation (in Wh/m, i.e., Watt-hours per meter).\n",
            "minimum": 0,
            "type": "number"
          },
          "freeFlowSpeedTable": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ConsumptionSpeedTable"
              }
            ]
          },
          "initialCharge": {
            "description": "Charge level of the vehicle's battery at the start of the route (in kWh).\nValue must be less than or equal to the value of `maxCharge`.\n",
            "minimum": 0,
            "type": "number"
          },
          "makeReachable": {
            "description": "When set to `true`, the router ensures that the calculated route is reachable within the given constraints\n(i.e., `minChargeAtChargingStation`, `minChargeAtDestination`). If necessary, charging stations are added to the route\nto achieve reachability.\n\nThe following conditions must be met in order to enable this option:\n* `transportMode=car`\n* `routingMode=fast`\n* `avoid` options requested, if any, should only be from `tollRoad`, `ferry`, `controlledAccessHighway`, `carShuttleTrain`, `tunnel`, `dirtRoad`.\nAvoid `controlledAccessHighway` and `tollRoad` options are limited to 300km air distance between 2 subsequent waypoints.\n",
            "type": "boolean"
          },
          "maxCharge": {
            "description": "Total capacity of the vehicle's battery (in kWh).\n",
            "minimum": 0,
            "type": "number"
          },
          "maxChargeAfterChargingStation": {
            "description": "Maximum charge to which the battery should be charged at a charging station (in kWh).\nValue must be less than or equal to the value of `maxCharge`.\n\nThe algorithm calculates a route as the best possible combination of driving and charging\nparts so charging at a charging station does not happen strictly to the value of\nthis parameter. Instead, the algorithm attempts to leave every station with\ndifferent charge levels, and only the best possible combination of charging stations\nand target charge will form the final route.\n\nFor example, if there is a fast but not reachable charging station on the route,\nthe algorithm prefers first to charge at a slower station, but only to a level that enables it\nto reach the fast station. This way it calculates the best possible combination of driving\nand charging parts.\n",
            "minimum": 0,
            "type": "number"
          },
          "maxChargingCurrent": {
            "description": "Maximum charging current supported by the vehicle's battery (in Ampere).\n",
            "minimum": 0,
            "type": "number"
          },
          "maxChargingVoltage": {
            "description": "Maximum charging voltage supported by the vehicle's battery (in Volt).\n",
            "minimum": 0,
            "type": "number"
          },
          "minChargeAtChargingStation": {
            "description": "Minimum charge when arriving at a charging station (in kWh).\nValue must be less than the value of `maxChargeAfterChargingStation`.\n\nThe algorithm calculates a route as the best possible combination of driving and charging\nparts so visiting a charging station is planned not when the remaining charge is close\nto the value of this parameter but when it is part of the best possible charging\nplan for the given route.\n\nFor example, it might prefer charging a still half-full battery at the fast charging station because\nthere are only slower stations later on the route and the remaining charge is not\nenough to reach the destination without charging at all.\n",
            "minimum": 0,
            "type": "number"
          },
          "minChargeAtDestination": {
            "description": "Minimum charge at the final route destination (in kWh).\nValue must be less than the value of `maxChargeAfterChargingStation`.\n\nThe algorithm calculates a route as the best possible combination of driving and charging\nparts while making sure that the actual value of the charge at the destination would be close to the\nvalue of this parameter. I.e., the resulting value is expected to be bigger\nthan this parameter's value by no more than 10% of the battery capacity.\n",
            "minimum": 0,
            "type": "number"
          },
          "minChargeAtFirstChargingStation": {
            "description": "Minimum charge when arriving at first charging station (in kWh).\nValue must be less than the value of `maxChargeAfterChargingStation`.\n\nThis overrides `minChargeAtChargingStation` for the first charging station. If not specified, `minChargeAtChargingStation`\nwill be used for all charging stations, including the first one.\n\nThis is usually used when the current charge is too low to reach a charging station within `minChargeAtChargingStation` limits.\n",
            "minimum": 0,
            "type": "number"
          },
          "preferredBrands": {
            "description": "Comma-separated list of charging station brand IDs. If `makeReachable` is set to `true`, then charging stations from the specified brands\nwill be preferred as potential charging stops, even if this makes the total route duration (travel time plus charging time) longer (up to 15 minutes per charging stop).\n",
            "type": "string"
          },
          "trafficSpeedTable": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ConsumptionSpeedTable"
              }
            ],
            "description": "Function curve specifying consumption rate at a given traffic-reduced speed on a flat stretch of road.\n\nSee `freeFlowSpeedTable` for a description of the string format.\n"
          }
        },
        "required": [
          "freeFlowSpeedTable"
        ],
        "type": "object"
      },
      "EVConsumption": {
        "description": "EV parameters to be used for calculating consumption.\n\nThe following attributes are required for calculating consumption:\n* `freeFlowSpeedTable`\n* `ascent`\n* `descent`\n\nThe following attributes are additionally required in order to calculate reachable routes:\n\n* `initialCharge`\n* `maxCharge`\n* `connectorTypes`\n* `chargingCurve`\n* `maxChargeAfterChargingStation`\n\nAll remaining attributes are optional.\n",
        "properties": {
          "ascent": {
            "description": "Rate of energy consumed per meter rise in elevation (in Wh/m, i.e., Watt-hours per meter).\n",
            "minimum": 0,
            "type": "number"
          },
          "auxiliaryConsumption": {
            "description": "Rate of energy (in Wh/s) consumed by the vehicle's auxiliary systems (for example, air conditioning, lights).\nThe value represents the number of Watt-hours consumed per second of travel.\n",
            "minimum": 0,
            "type": "number"
          },
          "chargingCurve": {
            "description": "Function curve describing the maximum battery charging rate (in kW) at a given charge level (in kWh).\n\nThe format of the string is a comma-separated list of numbers, as follows:\n\n```\n<CHARGE_0>,<RATE_0>,<CHARGE_1>,<RATE_1>,...,<RATE_N>,<CHARGE_N>\n```\n\nwhere charge values are strictly increasing, non-negative floating-point values in units\nof (kWh), and rate values are positive floating point values in units of (kW).\n\nCharge values must cover the entire range of `[0, maxChargeAfterChargingStation`]. The\ncharging curve is piecewise constant, e.g., for any charge in the range `[CHARGE_0,\nCHARGE_1)`, the value of the function is `RATE_0`.\n\nThe algorithm calculates a route as the best possible combination of driving and charging\nparts and uses the charging curve to evaluate the most efficent range of\ncharging. For example, if the rate of charging is high at lower levels of battery, but slows down significantly after charging a little, stopping\noften and charging less, but quicker, at each station might be better for the overall route.\nBecause batteries lose charging speed with use, providing a charging curve for the\nexact battery would give more accurate charging time estimate than providing a\ngeneric curve for all batteries of one type.\n",
            "example": "0,207,28.761,207,29.011,173,43.493,173,43.743,145,51.209,145,51.459,113,56.120,113,56.370,87,80.0,10",
            "type": "string"
          },
          "chargingSetupDuration": {
            "description": "Time spent (in seconds) after arriving at a charging station but before actually charging\n(for example, time spent for payment processing).\n",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "connectorTypes": {
            "description": "Comma-separated list of connector types that are compatible with the vehicle. If `makeReachable` is set to `true`,\nthen only stations with any of these connector types will be evaluated as a potential charging stop.\nFor stations with multiple compatible connectors, the charging time is based on the connector type with the highest power rating among them.\n\nCurrently supported connector types are:\n  * `iec62196Type1Combo`:  Type 1 Combo connector, commonly called \"SAE J1772\"\n  * `iec62196Type2Combo`:  Type 2 Combo connector, commonly called \"Mennekes\"\n  * `chademo`: CHAdeMO connector\n  * `tesla`: Tesla connector\n",
            "example": "iec62196Type1Combo,chademo",
            "type": "string"
          },
          "descent": {
            "description": "Rate of energy recovered per meter fall in elevation (in Wh/m, i.e., Watt-hours per meter).\n",
            "minimum": 0,
            "type": "number"
          },
          "freeFlowSpeedTable": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ConsumptionSpeedTable"
              }
            ]
          },
          "initialCharge": {
            "description": "Charge level of the vehicle's battery at the start of the route (in kWh).\nValue must be less than or equal to the value of `maxCharge`.\n",
            "minimum": 0,
            "type": "number"
          },
          "maxCharge": {
            "description": "Total capacity of the vehicle's battery (in kWh).\n",
            "minimum": 0,
            "type": "number"
          },
          "maxChargeAfterChargingStation": {
            "description": "Maximum charge to which the battery should be charged at a charging station (in kWh).\nValue must be less than or equal to the value of `maxCharge`.\n\nThe algorithm calculates a route as the best possible combination of driving and charging\nparts so charging at a charging station does not happen strictly to the value of\nthis parameter. Instead, the algorithm attempts to leave every station with\ndifferent charge levels, and only the best possible combination of charging stations\nand target charge will form the final route.\n\nFor example, if there is a fast but not reachable charging station on the route,\nthe algorithm prefers first to charge at a slower station, but only to a level that enables it\nto reach the fast station. This way it calculates the best possible combination of driving\nand charging parts.\n",
            "minimum": 0,
            "type": "number"
          },
          "maxChargingCurrent": {
            "description": "Maximum charging current supported by the vehicle's battery (in Ampere).\n",
            "minimum": 0,
            "type": "number"
          },
          "maxChargingVoltage": {
            "description": "Maximum charging voltage supported by the vehicle's battery (in Volt).\n",
            "minimum": 0,
            "type": "number"
          },
          "minChargeAtChargingStation": {
            "description": "Minimum charge when arriving at a charging station (in kWh).\nValue must be less than the value of `maxChargeAfterChargingStation`.\n\nThe algorithm calculates a route as the best possible combination of driving and charging\nparts so visiting a charging station is planned not when the remaining charge is close\nto the value of this parameter but when it is part of the best possible charging\nplan for the given route.\n\nFor example, it might prefer charging a still half-full battery at the fast charging station because\nthere are only slower stations later on the route and the remaining charge is not\nenough to reach the destination without charging at all.\n",
            "minimum": 0,
            "type": "number"
          },
          "minChargeAtDestination": {
            "description": "Minimum charge at the final route destination (in kWh).\nValue must be less than the value of `maxChargeAfterChargingStation`.\n\nThe algorithm calculates a route as the best possible combination of driving and charging\nparts while making sure that the actual value of the charge at the destination would be close to the\nvalue of this parameter. I.e., the resulting value is expected to be bigger\nthan this parameter's value by no more than 10% of the battery capacity.\n",
            "minimum": 0,
            "type": "number"
          },
          "minChargeAtFirstChargingStation": {
            "description": "Minimum charge when arriving at first charging station (in kWh).\nValue must be less than the value of `maxChargeAfterChargingStation`.\n\nThis overrides `minChargeAtChargingStation` for the first charging station. If not specified, `minChargeAtChargingStation`\nwill be used for all charging stations, including the first one.\n\nThis is usually used when the current charge is too low to reach a charging station within `minChargeAtChargingStation` limits.\n",
            "minimum": 0,
            "type": "number"
          },
          "trafficSpeedTable": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ConsumptionSpeedTable"
              }
            ],
            "description": "Function curve specifying consumption rate at a given traffic-reduced speed on a flat stretch of road.\n\nSee `freeFlowSpeedTable` for a description of the string format.\n"
          }
        },
        "required": [
          "freeFlowSpeedTable"
        ],
        "type": "object"
      },
      "EVPost": {
        "properties": {
          "preferredBrands": {
            "description": "An array of charging station brand IDs. If `makeReachable` is set to `true`, then charging stations from the specified brands\nwill be preferred as potential charging stops, even if this makes the total route duration (travel time plus charging time) longer (up to 15 minutes per charging stop)\n\nExample of a parameter value preferring two charging station brands:\n`[\"6e1a148e8ddf06f613599134197b7c1c\",\"6211c90a063d36429b599dda79ae85e3\"]`\n",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Energy": {
        "description": "Energy in kilowatt hours (kWh).",
        "type": "number"
      },
      "ErrorResponse": {
        "description": "Response in case of error",
        "properties": {
          "action": {
            "description": "Human-readable description of the action that can be taken to correct the error",
            "example": "Request a valid id",
            "type": "string"
          },
          "cause": {
            "description": "Human-readable explanation for the error",
            "example": "The input data in question does not comply with validation rules",
            "type": "string"
          },
          "code": {
            "description": "Error code.\n\nAll error codes start with \"`E60`\".\n",
            "example": "E600101",
            "type": "string"
          },
          "correlationId": {
            "description": "Auto-generated id that univocally identifies the request",
            "example": "4199533b-6290-41db-8d79-edf4f4019a74",
            "type": "string"
          },
          "status": {
            "description": "HTTP status code",
            "example": 400,
            "type": "integer"
          },
          "title": {
            "description": "Human-readable error description",
            "example": "Input data failed validation",
            "type": "string"
          }
        },
        "required": [
          "title",
          "status",
          "code",
          "cause",
          "action",
          "correlationId"
        ]
      },
      "Exclude": {
        "description": "Options to exclude strictly during the route calculation.",
        "properties": {
          "countries": {
            "description": "A comma separated list of three-letter country codes (ISO-3166-1 alpha-3 code) that\nroutes will exclude.\n",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ExitAction": {
        "description": "An action to leave a roundabout or highway.\n\n* `exit`: exit maneuver, such as \"Take the left exit to\"\n* `roundaboutExit`: roundabout exit maneuver, such as \"Take the third exit of the roundabout onto\"\n",
        "properties": {
          "action": {
            "description": "The type of the action.\n\n**NOTE:** The list of possible actions may be extended in the future. The client application should handle such a case gracefully.\n",
            "type": "string"
          },
          "currentRoad": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RoadInfo"
              }
            ],
            "description": "Attributes of the current road"
          },
          "direction": {
            "$ref": "#/components/schemas/TurnActionDirection"
          },
          "duration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "Estimated duration of this action (in seconds). Actions last until the next action, or the end of the route in case of the last one."
          },
          "exit": {
            "default": 1,
            "description": "Which exit to take next.",
            "maximum": 12,
            "minimum": 1,
            "type": "integer"
          },
          "exitSign": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ExitInfo"
              }
            ],
            "description": "Attributes of the road exit"
          },
          "instruction": {
            "description": "Description of the action (e.g. Turn left onto Minna St.).",
            "type": "string"
          },
          "intersectionName": {
            "description": "Name of the intersection where the turn takes place, if available.",
            "items": {
              "$ref": "#/components/schemas/LocalizedString"
            },
            "type": "array"
          },
          "length": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Distance"
              }
            ],
            "description": "Estimated length of this action (in meters). Actions extend until the next action, or the end of the route in case of the last one."
          },
          "nextRoad": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RoadInfo"
              }
            ],
            "description": "Attributes of the next road"
          },
          "offset": {
            "description": "Offset of a coordinate in the section's polyline.",
            "type": "integer"
          },
          "severity": {
            "$ref": "#/components/schemas/TurnActionSeverity"
          }
        },
        "required": [
          "action",
          "duration"
        ]
      },
      "ExitInfo": {
        "description": "Exit information attached to an offset action",
        "example": {
          "exit": {
            "number": [
              {
                "language": "de",
                "value": "15"
              }
            ]
          }
        },
        "properties": {
          "number": {
            "description": "Number of the exit (e.g. '18')",
            "items": {
              "$ref": "#/components/schemas/LocalizedString"
            },
            "type": "array"
          }
        }
      },
      "Fare": {
        "description": "`Fare` type contains information about a single fare or ticket needed for this section of the route.",
        "properties": {
          "convertedPrice": {
            "$ref": "#/components/schemas/FarePrice"
          },
          "id": {
            "description": "Unique Fare id. Used to deduplicate fares that apply to multiple sections",
            "type": "string"
          },
          "name": {
            "description": "Name of a fare",
            "type": "string"
          },
          "pass": {
            "$ref": "#/components/schemas/FarePass"
          },
          "paymentMethods": {
            "description": "Specifies the payment methods for which this fare is valid.\n",
            "items": {
              "$ref": "#/components/schemas/PaymentMethod"
            },
            "minItems": 1,
            "type": "array",
            "uniqueItems": true
          },
          "price": {
            "$ref": "#/components/schemas/FarePrice"
          },
          "reason": {
            "$ref": "#/components/schemas/FareReason",
            "default": "ride"
          }
        },
        "required": [
          "id",
          "name",
          "price"
        ]
      },
      "FarePass": {
        "description": "Specifies whether this `Fare` is a multi-travel pass, and its characteristics",
        "properties": {
          "returnJourney": {
            "description": "This pass includes the fare for the return journey.",
            "type": "boolean"
          },
          "seniorPass": {
            "description": "This pass is valid only if presented by a senior person.",
            "type": "boolean"
          },
          "transfers": {
            "description": "Indicates if transfers are permitted with this pass, and if so, how many.",
            "type": "integer"
          },
          "travels": {
            "description": "This pass allows for the specified number of travels.",
            "type": "integer"
          },
          "validityPeriod": {
            "$ref": "#/components/schemas/FarePassValidityPeriod"
          }
        }
      },
      "FarePassValidityPeriod": {
        "description": "Specifies a temporal validity period for a pass",
        "properties": {
          "count": {
            "description": "Required if period is `minutes`, days` or `months`, it specifies how many of these units are covered by the pass.",
            "type": "integer"
          },
          "period": {
            "description": "Extensible enum: `annual` `extendedAnnual` `minutes` `days` `months` `...`  \nSpecifies one of the following validity periods:\n  - `annual`: pass is valid from Jan 1 to Dec 31\n  - `extendedAnnual`: pass is valid from Jan 1 to Jan 31 of the following year\n  - `minutes`: pass is valid for a specified number of minutes See `unit`.\n  - `days`: pass is valid for a specified number of days. See `unit`.\n  - `months`: pass is valid for a specified number of months. See `unit`.\n",
            "type": "string",
            "x-extensible-enum": [
              "annual",
              "extendedAnnual",
              "minutes",
              "days",
              "months"
            ]
          }
        },
        "required": [
          "period"
        ]
      },
      "FarePrice": {
        "description": "Price of a fare",
        "discriminator": {
          "mapping": {
            "range": "#/components/schemas/RangePrice",
            "value": "#/components/schemas/SinglePrice"
          },
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/SinglePrice"
          },
          {
            "$ref": "#/components/schemas/RangePrice"
          }
        ]
      },
      "FareReason": {
        "description": "Extensible enum: `ride` `parking` `...`  \nReason for the cost described in this `Fare` element.\n",
        "type": "string",
        "x-extensible-enum": [
          "ride",
          "parking"
        ]
      },
      "FunctionalClass": {
        "description": "Functional class is used to classify roads depending on the speed, importance and\nconnectivity of the road.\n\n* `1`: Roads allow for high volume, maximum speed traffic movement between and through major\n  metropolitan areas.\n* `2`: Roads are used to channel traffic to functional class 1 roads for travel between and\n  through cities in the shortest amount of time.\n* `3`: Roads that intersect functional class 2 roads and provide a high volume of traffic\n  movement at a lower level of mobility than functional class 2 roads.\n* `4`: Roads that provide for a high volume of traffic movement at moderate speeds between\n  neighbourhoods.\n* `5`: Roads with volume and traffic movement below the level of any other functional class.\n",
        "format": "int32",
        "maximum": 5,
        "minimum": 1,
        "type": "integer"
      },
      "GetRoutesByHandlePostParameters": {
        "description": "Parameters of the POST body for get route by handle",
        "example": {
          "$ref": "#/components/examples/calculateRoutesPostParametersExample"
        },
        "properties": {
          "avoid": {
            "$ref": "#/components/schemas/AvoidPost"
          },
          "maxSpeedOnSegment": {
            "$ref": "#/components/schemas/MaxSpeedOnSegmentPost"
          }
        },
        "type": "object"
      },
      "HazardousGoodsRestriction": {
        "description": "Extensible enum: `explosive` `gas` `flammable` `combustible` `organic` `poison` `radioactive` `corrosive` `poisonousInhalation` `harmfulToWater` `other` `any` `...`  \nHazardous goods restriction applied during the trip.\n\n* `explosive`: Explosive material\n* `gas`: Gas\n* `flammable`: Flammable material\n* `combustible`: Combustible material\n* `organic`: Organic material\n* `poison`: Poison\n* `radioactive`: Radioactive material\n* `corrosive`: Corrosive material\n* `poisonousInhalation`: Materials that are poisonous upon inhalation\n* `harmfulToWater`: Materials that are harmful to water\n* `other`: Other types of hazardous materials\n* `any`: Any of the above types\n",
        "type": "string",
        "x-extensible-enum": [
          "explosive",
          "gas",
          "flammable",
          "combustible",
          "organic",
          "poison",
          "radioactive",
          "corrosive",
          "poisonousInhalation",
          "harmfulToWater",
          "other",
          "any"
        ]
      },
      "HealthResponseFailSchema": {
        "description": "Returns the health of the service",
        "properties": {
          "status": {
            "description": "Health status of the service:\n\n* `ok` - the service is operating normally\n* `fail` - the service is currently encountering a failure\n",
            "enum": [
              "fail"
            ],
            "type": "string"
          }
        }
      },
      "HealthResponseOKSchema": {
        "description": "Returns the health of the service",
        "properties": {
          "status": {
            "description": "Health status of the service:\n\n* `ok` - the service is operating normally\n* `fail` - the service is currently encountering a failure\n",
            "enum": [
              "ok"
            ],
            "type": "string"
          }
        }
      },
      "ImportGeoBody": {
        "discriminator": {
          "mapping": {
            "LineString": "#/components/schemas/LineString"
          },
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/LineString"
          }
        ]
      },
      "KeepAction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/TurnAction"
          }
        ]
      },
      "LineString": {
        "description": "GeoJSON encoding of type 'LineString'",
        "example": {
          "value": {
            "coordinates": [
              [
                52,
                13
              ],
              [
                52.01,
                13.01
              ]
            ],
            "type": "LineString"
          }
        },
        "properties": {
          "coordinates": {
            "items": {
              "items": {
                "format": "double",
                "type": "number"
              },
              "minItems": 2,
              "type": "array"
            },
            "type": "array"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "coordinates"
        ],
        "type": "object"
      },
      "LocalizedString": {
        "description": "String with optional language code.",
        "example": {
          "language": "de",
          "value": "Invalidenstraße"
        },
        "properties": {
          "language": {
            "description": "Language in BCP47 format",
            "type": "string"
          },
          "value": {
            "description": "String written in the language specified in the language property.",
            "type": "string"
          }
        },
        "required": [
          "value"
        ]
      },
      "Location": {
        "description": "Location on the Earth",
        "example": {
          "lat": 52.531677,
          "lng": 13.381777
        },
        "properties": {
          "elv": {
            "description": "Ellipsoid(geodetic) height in meters. Difference between the WGS84 ellipsoid and a point on the Earth’s surface.\nNote: Similar elevation can be obtained from a GPS receiver.\n",
            "example": 512.5,
            "type": "number"
          },
          "lat": {
            "description": "Location of a point on the Earth north or south of the equator in decimal degrees.",
            "example": 52.531677,
            "format": "double",
            "type": "number"
          },
          "lng": {
            "description": "Location of a place on the Earth east or west of the prime meridian in decimal degrees.",
            "example": 13.381777,
            "format": "double",
            "type": "number"
          }
        },
        "required": [
          "lat",
          "lng"
        ]
      },
      "MatchTrace": {
        "description": "Trace file with points and path match parameters",
        "example": {
          "$ref": "#/components/examples/matchTraceExample"
        },
        "properties": {
          "trace": {
            "items": {
              "$ref": "#/components/schemas/MatchTracePoint"
            },
            "maxItems": 50000,
            "minItems": 2,
            "type": "array"
          },
          "via": {
            "items": {
              "$ref": "#/components/schemas/MatchTraceVia"
            },
            "type": "array"
          }
        },
        "required": [
          "trace"
        ],
        "type": "object"
      },
      "MatchTracePoint": {
        "description": "GPS probe point with parameters relevant to path or route matching",
        "properties": {
          "lat": {
            "description": "Latitude in degrees",
            "format": "double",
            "type": "number"
          },
          "lng": {
            "description": "Longitude in degrees",
            "format": "double",
            "type": "number"
          }
        },
        "required": [
          "lat",
          "lng"
        ]
      },
      "MatchTraceVia": {
        "description": "Via waypoint in the middle of route",
        "properties": {
          "index": {
            "description": "Index of the corresponding trace point",
            "minimum": 1,
            "type": "integer"
          },
          "stopDuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "Desired duration for the stop, in seconds"
          }
        },
        "required": [
          "index"
        ]
      },
      "MaxSpeed": {
        "description": "Speed in meters per second, or \"unlimited\" indicating that the speed is unlimited, e.g., on a German autobahn",
        "oneOf": [
          {
            "minimum": 0,
            "type": "number"
          },
          {
            "enum": [
              "unlimited"
            ],
            "type": "string"
          }
        ]
      },
      "MaxSpeedOnSegment": {
        "description": "A comma separated list of segments with restrictions on maximum baseSpeed.\n\nEach entry has the following structure:\n`{segmentId}(#{direction})?;speed={maxBaseSpeed}`\n\nThe individual parts are:\n* segmentId: The identifier of the referenced topology segment inside the catalog, example: `here:cm:segment:207551710`\n* direction (optional): Either '*' for bidirectional (default), '+' for positive direction, or '-' for negative direction\n* maxBaseSpeed: New value in m/s of baseSpeed on segment\n\nExample of a parameter value excluding two segments:\n`here:cm:segment:207551710#+;speed=10,here:cm:segment:76771992;speed=1`\n\n**Notes**:\n- It does not increase default baseSpeed on segment. If the value is greater than the default base speed, then such penalty will have no effect.\n- Minimum valid value for speed is 1\n- Using segments with a modified base speed does not trigger any notifications\n- Maximum amount of penalized segments in one request cannot be greater than 250.\n  A \"penalized segments\" refers to segments that have a restrictions on maximum baseSpeed with `maxSpeedOnSegment`\n  or avoided with `avoid[segments]`\n",
        "type": "string"
      },
      "MaxSpeedOnSegmentPost": {
        "description": "Segments with restrictions on maximum `baseSpeed`.\n\nFor the general description of the functionality please refer to the `maxSpeedOnSegment` parameter of the\nquery string.\n\nPassing parameters in the POST body is suggested when the length of the parameters exceeds the\nlimitation of the GET request.\n\nExample of a parameter value excluding two segments:\n```\n[\n  {\n    \"segment\": \"here:cm:segment:207551710#+\",\n    \"speed\": 10\n  },\n  {\n    \"segment\": \"here:cm:segment:76771992\",\n    \"speed\": 1\n  }\n]\n```\n\n**Notes**: Maximum amount of penalized segments in one request cannot be greater than 250.\n  A \"penalized segments\" refers to segments that have a restrictions on maximum baseSpeed with `maxSpeedOnSegment`\n  or avoided with `avoid[segments]`\n",
        "items": {
          "properties": {
            "segment": {
              "description": "Identifier of the segment with restrictions on maximum `baseSpeed`.\n\nEach entry has the following structure:\n`{segmentId}(#{direction})?`\n",
              "type": "string"
            },
            "speed": {
              "description": "Maximum `baseSpeed` on segment in m/s.\n",
              "maximum": 69.99,
              "minimum": 1,
              "type": "number"
            }
          },
          "type": "object"
        },
        "type": "array"
      },
      "Notice": {
        "description": "A notice contains important notifications.",
        "properties": {
          "code": {
            "description": "Notice code.",
            "example": "noRouteFound",
            "type": "string"
          },
          "details": {
            "description": "Additional details about the notice",
            "items": {
              "$ref": "#/components/schemas/BaseNoticeDetail"
            },
            "type": "array"
          },
          "severity": {
            "$ref": "#/components/schemas/NoticeSeverity"
          },
          "title": {
            "description": "Human-readable notice description.",
            "example": "No route found",
            "type": "string"
          }
        },
        "required": [
          "code"
        ]
      },
      "NoticeSeverity": {
        "description": "Describes the impact a notice has on the resource to which the notice is attached.\n* critical - The notice must not be ignored, even if the type of notice is not known to the user. Any associated resource (e.g., route section) must not be used without further evaluation.\n* info - The notice is for informative purposes, but does not affect usability of the route.\n",
        "enum": [
          "critical",
          "info"
        ],
        "type": "string"
      },
      "OffsetAction": {
        "description": "An action to be performed at or during a specific portion of a section.\n\n* `depart`: departure maneuver, such as \"Start at\"\n* `arrive`: arrival maneuver, such as \"Arrive at\"\n* `continue`: continue maneuver, such as \"Continue on\"\n",
        "properties": {
          "action": {
            "description": "The type of the action.\n\n**NOTE:** The list of possible actions may be extended in the future. The client application should handle such a case gracefully.\n",
            "type": "string"
          },
          "currentRoad": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RoadInfo"
              }
            ],
            "description": "Attributes of the current road"
          },
          "duration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "Estimated duration of this action (in seconds). Actions last until the next action, or the end of the route in case of the last one."
          },
          "exitSign": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ExitInfo"
              }
            ],
            "description": "Attributes of the road exit"
          },
          "instruction": {
            "description": "Description of the action (e.g. Turn left onto Minna St.).",
            "type": "string"
          },
          "length": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Distance"
              }
            ],
            "description": "Estimated length of this action (in meters). Actions extend until the next action, or the end of the route in case of the last one."
          },
          "nextRoad": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RoadInfo"
              }
            ],
            "description": "Attributes of the next road"
          },
          "offset": {
            "description": "Offset of a coordinate in the section's polyline.",
            "type": "integer"
          }
        },
        "required": [
          "action",
          "duration"
        ]
      },
      "ParkingLotPlace": {
        "description": "A parking lot",
        "properties": {
          "attributes": {
            "description": "Attributes of a parking lot.",
            "items": {
              "$ref": "#/components/schemas/ParkingLotPlaceType"
            },
            "type": "array"
          },
          "id": {
            "description": "Identifier of this parking lot",
            "type": "string"
          },
          "location": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Location"
              }
            ],
            "description": "The position of this location\n\nThis position was used in route calculation. It may be different to the original position provided in the request.\n"
          },
          "name": {
            "description": "Location name",
            "type": "string"
          },
          "originalLocation": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Location"
              }
            ],
            "description": "If present, the original position of this location provided in the request."
          },
          "rates": {
            "description": "List of possible parking rates for this facility. Different rates can apply depending on the day, time of the day or parking duration.\n",
            "items": {
              "$ref": "#/components/schemas/TimeRestrictedPrice"
            },
            "type": "array"
          },
          "type": {
            "description": "Place type. Each place type can have extra attributes.\n\n**NOTE:** The list of possible place types could be extended in the future.\nThe client application is expected to handle such a case gracefully.\n",
            "type": "string"
          },
          "waypoint": {
            "description": "If present, this place corresponds to the waypoint in the request with the same index.",
            "type": "integer"
          }
        },
        "required": [
          "type",
          "location"
        ]
      },
      "ParkingLotPlaceType": {
        "description": "Extensible enum: `parkAndRide` `...`  \nCurrently possible values are:\n\n* `parkAndRide` - this parking lot is of type \"Park and Ride\",\n  such as it is a parking specifically designed to allow transition between car and transit.\n",
        "type": "string",
        "x-extensible-enum": [
          "parkAndRide"
        ]
      },
      "PartialTime": {
        "description": "**RFC 3339**, section 5.6 as defined by `partial-time`.",
        "example": 30600,
        "pattern": "^[012]\\d:[0-5]\\d:[0-6]\\d(\\.\\d+)?$",
        "type": "string"
      },
      "Passthrough": {
        "description": "Describes a location and time the section is passing through.",
        "properties": {
          "offset": {
            "description": "Passthrough offsets are the coordinate index in the polyline.",
            "type": "number"
          },
          "place": {
            "$ref": "#/components/schemas/Place"
          }
        },
        "required": [
          "place"
        ]
      },
      "PaymentMethod": {
        "description": "Extensible enum: `cash` `bankCard` `creditCard` `passSubscription` `transponder` `videoToll` `cashExact` `travelCard` `...`  \nRecognized methods of payment.\n",
        "type": "string",
        "x-extensible-enum": [
          "cash",
          "bankCard",
          "creditCard",
          "passSubscription",
          "transponder",
          "videoToll",
          "cashExact",
          "travelCard"
        ]
      },
      "PedestrianAction": {
        "description": "Action attached to a pedestrian section.",
        "discriminator": {
          "mapping": {
            "arrive": "#/components/schemas/ArriveAction",
            "continue": "#/components/schemas/ContinueAction",
            "depart": "#/components/schemas/DepartAction",
            "exit": "#/components/schemas/ExitAction",
            "keep": "#/components/schemas/KeepAction",
            "ramp": "#/components/schemas/RampAction",
            "roundaboutEnter": "#/components/schemas/RoundaboutEnterAction",
            "roundaboutExit": "#/components/schemas/RoundaboutExitAction",
            "roundaboutPass": "#/components/schemas/RoundaboutPassAction",
            "turn": "#/components/schemas/TurnAction",
            "uTurn": "#/components/schemas/UTurnAction"
          },
          "propertyName": "action"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/DepartAction"
          },
          {
            "$ref": "#/components/schemas/ArriveAction"
          },
          {
            "$ref": "#/components/schemas/ContinueAction"
          },
          {
            "$ref": "#/components/schemas/RampAction"
          },
          {
            "$ref": "#/components/schemas/ExitAction"
          },
          {
            "$ref": "#/components/schemas/RoundaboutPassAction"
          },
          {
            "$ref": "#/components/schemas/RoundaboutEnterAction"
          },
          {
            "$ref": "#/components/schemas/RoundaboutExitAction"
          },
          {
            "$ref": "#/components/schemas/UTurnAction"
          },
          {
            "$ref": "#/components/schemas/TurnAction"
          },
          {
            "$ref": "#/components/schemas/KeepAction"
          }
        ]
      },
      "PedestrianDeparture": {
        "description": "Departure of pedestrian",
        "properties": {
          "place": {
            "$ref": "#/components/schemas/PedestrianPlace"
          },
          "time": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Time"
              }
            ],
            "description": "Expected time of departure of the event. Format is **RFC 3339**, section 5.6 as defined by `date-time`."
          }
        },
        "required": [
          "place"
        ]
      },
      "PedestrianMode": {
        "default": "pedestrian",
        "description": "Extensible enum: `pedestrian` `...`  \nPedestrian mode of transport.\n\nSince the supported pedestrian modes may be extended in the future, the pedestrian mode should be hidden when an unknown mode is encountered.\n",
        "type": "string",
        "x-extensible-enum": [
          "pedestrian"
        ]
      },
      "PedestrianNotice": {
        "description": "A notice contains important notifications.",
        "properties": {
          "code": {
            "description": "Extensible enum: `simplePolyline` `pedestrianOptionViolated` `violatedAvoidTunnel` `violatedAvoidDirtRoad` `...`  \nCurrently known codes (non-exhaustive: this list could be extended for new situations):\n\n| Code      | Description  | Severity |\n| --------- | ------- | ----            |\n| simplePolyline | An accurate polyline is not available for this section. The returned polyline has been generated from departure and arrival places | info |\n| pedestrianOptionViolated | This section violates the parameter `pedestrian[speed]` or `pedestrian[maxDistance]` | critical |\n| violatedAvoidTunnel | Route did not manage to avoid user preference | critical |\n| violatedAvoidDirtRoad | Route did not manage to avoid user preference | critical |\n",
            "example": "violatedAvoidTunnel",
            "type": "string",
            "x-extensible-enum": [
              "simplePolyline",
              "pedestrianOptionViolated",
              "violatedAvoidTunnel",
              "violatedAvoidDirtRoad"
            ]
          },
          "details": {
            "description": "Additional details about the notice",
            "items": {
              "$ref": "#/components/schemas/BaseNoticeDetail"
            },
            "type": "array"
          },
          "severity": {
            "$ref": "#/components/schemas/NoticeSeverity"
          },
          "title": {
            "description": "Human-readable notice description.",
            "example": "Violated avoid tunnel",
            "type": "string"
          }
        },
        "required": [
          "code"
        ]
      },
      "PedestrianPlace": {
        "description": "Place used in pedestrian routing",
        "discriminator": {
          "mapping": {
            "accessPoint": "#/components/schemas/AccessPointPlace",
            "chargingStation": "#/components/schemas/ChargingStationPlace",
            "dockingStation": "#/components/schemas/DockingStationPlace",
            "parkingLot": "#/components/schemas/ParkingLotPlace",
            "place": "#/components/schemas/Place",
            "station": "#/components/schemas/StationPlace"
          },
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/Place"
          },
          {
            "$ref": "#/components/schemas/StationPlace"
          },
          {
            "$ref": "#/components/schemas/AccessPointPlace"
          },
          {
            "$ref": "#/components/schemas/ParkingLotPlace"
          },
          {
            "$ref": "#/components/schemas/ChargingStationPlace"
          },
          {
            "$ref": "#/components/schemas/DockingStationPlace"
          }
        ]
      },
      "PedestrianPostAction": {
        "discriminator": {
          "mapping": {
            "wait": "#/components/schemas/OffsetAction"
          },
          "propertyName": "action"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/OffsetAction"
          }
        ]
      },
      "PedestrianSection": {
        "description": "Represent a section of a route",
        "properties": {
          "actions": {
            "description": "Actions to be performed at or during a specific portion of a section.\n\nAction offsets are the coordinate index in the polyline.\n\n*NOTE:* currentRoad and nextRoad are not populated for actions.\n",
            "items": {
              "$ref": "#/components/schemas/PedestrianAction"
            },
            "type": "array"
          },
          "arrival": {
            "$ref": "#/components/schemas/PedestrianDeparture"
          },
          "departure": {
            "$ref": "#/components/schemas/PedestrianDeparture"
          },
          "id": {
            "description": "Unique identifier of the section",
            "type": "string"
          },
          "language": {
            "description": "Language of the localized strings in the section, if any, in BCP47 format.",
            "type": "string"
          },
          "notices": {
            "description": "Contains a list of issues related to this section of the route.\n",
            "items": {
              "$ref": "#/components/schemas/PedestrianNotice"
            },
            "type": "array"
          },
          "passthrough": {
            "description": "List of via waypoints this section is passing through.\n\nEach via waypoint of the request that is a `passThrough=true` waypoint, appears as a\n`Passthrough` in the response. It appears in the section that starts with the closest\nnon-passthrough via specified before it or origin.\n\nThe passthrough vias appear in this list in the order they are traversed. They are\ntraversed in the order they are specified in the request.\n",
            "items": {
              "$ref": "#/components/schemas/Passthrough"
            },
            "type": "array"
          },
          "polyline": {
            "$ref": "#/components/schemas/Polyline"
          },
          "postActions": {
            "description": "Actions that must be done after `arrival`.",
            "items": {
              "$ref": "#/components/schemas/PedestrianPostAction"
            },
            "type": "array"
          },
          "preActions": {
            "description": "Actions that must be done prior to `departure`.",
            "items": {
              "$ref": "#/components/schemas/BaseAction"
            },
            "type": "array"
          },
          "refReplacements": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Dictionary of placeholders to replacement strings for the compact representation of map entity references.\n",
            "type": "object"
          },
          "spans": {
            "description": "Spans attached to a `Section` describing pedestrian content.\n",
            "items": {
              "$ref": "#/components/schemas/PedestrianSpan"
            },
            "type": "array"
          },
          "summary": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PedestrianSummary"
              }
            ],
            "description": "Total value of key attributes (e.g. duration, length) summed up for the entire section, including `preActions`, `postActions`,\nand the travel portion of the section.\n"
          },
          "transport": {
            "$ref": "#/components/schemas/PedestrianTransport"
          },
          "travelSummary": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BaseSummary"
              }
            ],
            "description": "Total value of key attributes (e.g., duration, length) summed up for just the travel portion of the section,\nbetween `departure` and `arrival`. `preActions` and `postActions` are excluded.\n"
          },
          "turnByTurnActions": {
            "description": "Actions for turn by turn guidance during the travel portion of the section, i.e., between `departure` and `arrival`.",
            "items": {
              "$ref": "#/components/schemas/OffsetAction"
            },
            "type": "array"
          },
          "type": {
            "description": "Section type used by the client to identify what extension to the BaseSection are available.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "type",
          "departure",
          "arrival",
          "transport"
        ]
      },
      "PedestrianSpan": {
        "description": "Span attached to a `Section` describing pedestrian content.\n",
        "properties": {
          "baseDuration": {
            "$ref": "#/components/schemas/Duration",
            "description": "Duration of this span (in seconds) ignoring time-aware information.\n\nFor pedestrian mode, the reported time is currently equal to that in `duration`.\n"
          },
          "carAttributes": {
            "description": "Car specific `AccessAttributes`.\n\n`AccessAttributes` is applied to a span of a route section and describes access flags of a street.\n* `open`:  A part of the route that is open to cars.\n* `noThrough`:  A part of the route that can only be traversed if origin, destination or any via waypoint is located there.\n* `tollRoad`: Access to this part of the route is restricted with a fee (or toll).\n\nAs it is possible that new access attributes are supported in the future, unknown access attributes should be ignored.\n",
            "items": {
              "$ref": "#/components/schemas/AccessAttributes"
            },
            "type": "array"
          },
          "countryCode": {
            "$ref": "#/components/schemas/CountryCode"
          },
          "duration": {
            "$ref": "#/components/schemas/Duration",
            "description": "Duration of the span."
          },
          "dynamicSpeedInfo": {
            "$ref": "#/components/schemas/DynamicSpeedInfo"
          },
          "functionalClass": {
            "$ref": "#/components/schemas/FunctionalClass"
          },
          "incidents": {
            "description": "A list of indices into the incident array of the parent section.\nReferences all incidents that apply to the span.\n",
            "items": {
              "type": "integer"
            },
            "type": "array"
          },
          "length": {
            "$ref": "#/components/schemas/Distance",
            "description": "Length of the span.\n"
          },
          "maxSpeed": {
            "$ref": "#/components/schemas/MaxSpeed"
          },
          "names": {
            "description": "Designated name for the span (e.g. a street name or a transport name)",
            "items": {
              "$ref": "#/components/schemas/LocalizedString"
            },
            "type": "array"
          },
          "offset": {
            "description": "Offset of a coordinate in the section's polyline.\n",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "routeNumbers": {
            "description": "Designated route name or number of the span (e.g. 'M25')",
            "items": {
              "$ref": "#/components/schemas/LocalizedString"
            },
            "type": "array"
          },
          "scooterAttributes": {
            "description": "Scooter specific `AccessAttributes`.\n\n`AccessAttributes` is applied to a span of a route section and describes access flags of a street.\n* `open`: This part of the route is open to scooters.\n\nAs it is possible that new access attributes are supported in the future, unknown access attributes should be ignored.\n",
            "items": {
              "$ref": "#/components/schemas/AccessAttributes"
            },
            "type": "array"
          },
          "segmentId": {
            "deprecated": true,
            "description": "**NOTE:** Attribute segmentId is deprecated. Use segmentRef instead.\n\nThe directed topology segment id including prefix (e.g '+here:cm:segment:').\n\nThe id consists of two parts.\n* The direction ('+' or '-')\n* followed by the topology segment id (a unique identifier within the HERE platform catalogs).\n\nThe direction specifies whether the route is using the segment in its canonical direction ('+' aka traveling along the geometry's direction), or against it ('-' aka traveling against the geometry's direction).\n",
            "type": "string"
          },
          "segmentRef": {
            "description": "A reference to the HMC topology segment used in this span.\n\nThe standard representation of a segment reference has the following structure:\n{catalogHrn}:{catalogVersion}:({layerId})?:{tileId}:{segmentId}(#{direction}({startOffset}..{endOffset})?)?\n\nThe individual parts are:\n* catalogHrn: The HERE Resource Name that identifies the source catalog of the segment, example: hrn:here:data::olp-here:rib-2\n* catalogVersion: The catalog version\n* layerId (optional): The layer inside the catalog where the segment can be found, example: topology-geometry\n* tileId: The HERE tile key of the partition/tile where the segment is located in the given version of the catalog. This can be on a lower level than the actual segment is stored at (for example, the provided tile ID can be on level 14, despite topology-geometry partitions being tiled at level 12). The level of a HERE tile key is indicated by the position of the highest set bit in binary representation. Since the HERE tile key represents a morton code of the x and y portion of the Tile ID, the level 12 tile ID can be retrieved from the level 14 tile ID by removing the 4 least significant bits (or 2 bits per level) or 1 hexadecimal digit. For example, the level 14 tile 377894441 is included in the level 12 tile 23618402 (377894441<sub>10</sub> = 16863629<sub>16</sub> &rightarrow; 1686362<sub>16</sub> = 23618402<sub>10</sub>)\n* segmentId: The identifier of the referenced topology segment inside the catalog, example: here:cm:segment:84905195\n* direction (optional): Either '*' for undirected or bidirectional, '+' for positive direction, '-' for negative direction, or '?' for unknown direction (not used by the routing service)\n* startOffset/endOffset (optional): The start- and end offset are non-negative numbers between 0 and 1, representing the start and end of the referenced range using a proportion of the length of the segment. 0 represents the start and 1 the end of the segment, relative to the indicated direction (or positive direction in case of undirected segments). Example: 0.7..1\n\nExample of a segment reference in standard representation:\nhrn:here:data::olp-here:rib-2:1363::377894441:here:cm:segment:84905195#+0.7..1\n\nThe segment references can also be provided in a compact representation, to reduce the response size. In the compact representation, some parts are replaced by placeholders, which can be resolved using the refReplacements dictionary in the parent section.\nThe placeholder format is ```\\$\\d+``` and needs to be surrounded by colons or string start/end. It can be captured with the following regular expression: ```(^|:)\\$\\d+(:|$)/``` .\n\nExample of the segment reference previously mentioned in compact representation:\n$0:377894441:$1:84905195#+0.7..1\nWith the corresponding refReplacements:\n\"refReplacements\": {\n  \"0\": \"hrn:here:data::olp-here:rib-2:1363:\",\n  \"1\": \"here:cm:segment\"\n}\n",
            "type": "string"
          },
          "speedLimit": {
            "$ref": "#/components/schemas/Speed",
            "description": "**NOTE:** Attribute speedLimit is deprecated. Use maxSpeed instead.\n"
          },
          "stateCode": {
            "$ref": "#/components/schemas/StateCode"
          },
          "streetAttributes": {
            "description": "`StreetAttributes` is applied to a span of a route section and describes attribute flags of a street.\n* `rightDrivingSide`: Do vehicles have to drive on the right-hand side of the road or the left-hand side.\n* `dirtRoad`: This part of the route has an un-paved surface.\n* `tunnel`: This part of the route is a tunnel.\n* `bridge`: This part of the route is a bridge.\n* `ramp`: This part of the route is a ramp (usually connecting to/from/between highways).\n* `motorway`: This part of the route is a controlled access road (usually highways with motorway sign).\n* `roundabout`: This part of the route is a roundabout.\n* `underConstruction`: This part of the route is under construction.\n* `dividedRoad`: This part of the route uses a road with a physical or legal divider in the middle.\n* `privateRoad`: This part of the route uses a privately owned road.\n* `controlledAccessHighway`: This part of the route is a either controlled access or limited access road or both.\n\nAs it is possible that new street attributes are supported in the future, unknown street attributes should be ignored.\n",
            "items": {
              "$ref": "#/components/schemas/StreetAttributes"
            },
            "type": "array"
          },
          "truckAttributes": {
            "description": "Truck specific `AccessAttributes`.\n\n`AccessAttributes` is applied to a span of a route section and describes access flags of a street.\n* `open`: This part of the route is open to trucks.\n* `noThrough`: This part of the route can only be traversed if origin, destination or any via waypoint is located there.\n* `tollRoad`: This part of the route is restricted with a fee (or toll).\n\nAs it is possible that new access attributes are supported in the future, unknown access attributes should be ignored.\n",
            "items": {
              "$ref": "#/components/schemas/AccessAttributes"
            },
            "type": "array"
          },
          "typicalDuration": {
            "$ref": "#/components/schemas/Duration",
            "description": "Duration of this span (in seconds) under typical traffic conditions.\n\nFor pedestrian mode, the reported time is currently equal to that in `duration`.\n"
          },
          "walkAttributes": {
            "description": "Accessibility and walk-related attribute flags.\n\n* `stairs`: This part of the route is a staircase.\n* `park`: This part of the route is in a park.\n* `indoor`: This part of the route is inside a venue.\n* `open`: This part of the route is open to walking.\n* `noThrough`: This part of the route can only be traversed if origin, destination or any via waypoint is located there.\n* `tollRoad`: Access to this part of the route is restricted with a fee (or toll).\n\nAs it is possible that new attributes are supported in the future, unknown attributes should be ignored.\n",
            "items": {
              "$ref": "#/components/schemas/WalkAttributes"
            },
            "type": "array"
          }
        }
      },
      "PedestrianSpeed": {
        "default": 1,
        "description": "Pedestrian speed in meters per second",
        "maximum": 2,
        "minimum": 0.5,
        "type": "number"
      },
      "PedestrianSummary": {
        "description": "Total value of key attributes for a route section.",
        "properties": {
          "baseDuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "Duration (in seconds) ignoring time-aware information.\n\nFor pedestrian mode, the reported time is currently equal to that in `duration`.\n"
          },
          "duration": {
            "$ref": "#/components/schemas/Duration"
          },
          "length": {
            "$ref": "#/components/schemas/Distance"
          }
        },
        "required": [
          "duration",
          "length"
        ]
      },
      "PedestrianTransport": {
        "description": "Information about a transport",
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/PedestrianMode"
          }
        },
        "required": [
          "mode"
        ]
      },
      "Place": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BasePlace"
          }
        ],
        "description": "A place represents a generic location relevant for the route."
      },
      "Polyline": {
        "description": "Line string in [Flexible Polyline](https://github.com/heremaps/flexible-polyline) format.",
        "example": "A05xgKuy2xCx9B7vUl0OhnR54EqSzpEl-HxjD3pBiGnyGi2CvwFsgD3nD4vB6e",
        "type": "string"
      },
      "RampAction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/TurnAction"
          }
        ]
      },
      "RangePrice": {
        "properties": {
          "currency": {
            "description": "Local currency of the price compliant to ISO 4217",
            "type": "string"
          },
          "estimated": {
            "default": false,
            "description": "Attribute value is `true` if the fare price is estimated, `false` if it is an exact value.",
            "type": "boolean"
          },
          "maximum": {
            "description": "Maximum price",
            "type": "number"
          },
          "minimum": {
            "description": "Minimum price",
            "type": "number"
          },
          "type": {
            "description": "Type of price represented by this object. The API customer is responsible for correctly visualizing\nthe pricing model. As it is possible to extend the supported price types in the future,\nthe price information should be hidden when an unknown type is encountered.\n\nAvailable price types are:\n\n  * `value` - A single value.\n  * `range` - A range value that includes a minimum and maximum price.\n",
            "type": "string"
          },
          "unit": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "When set, the price is paid for a specific duration.\n\nExamples:\n  * `\"unit\": 3600` - price for one hour\n  * `\"unit\": 28800` - price for 8 hours\n  * `\"unit\": 86400` - price for one day\n"
          }
        },
        "required": [
          "type",
          "currency",
          "minimum",
          "maximum"
        ]
      },
      "Rerouting": {
        "description": "Rerouting parameters allow to request a new route calculation based on the route handle.\n\nAll attributes are optional.\n",
        "example": {
          "$ref": "#/components/examples/ReroutingExample"
        },
        "properties": {
          "lastTraveledSectionIndex": {
            "default": 0,
            "description": "Indicates the index of the last traveled route section. Traveled part of the route won't\nbe reused.\n",
            "type": "integer"
          },
          "mode": {
            "$ref": "#/components/schemas/ReroutingMode"
          },
          "traveledDistanceOnLastSection": {
            "default": 0,
            "description": "Offset in meter to the last visited position on the route section defined by the `lastTraveledSectionIndex`.\n",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ReroutingMode": {
        "description": "Defines what kind of additional route calculation should be done.\n\n* `none` - Cuts off route before the current position. Updates dynamic attributes of the\nroute after the current position. If the current position, i.e., the new `origin`, is defined and is\noutside of the original route then the request will fail. If both `origin` and\n`lastTraveledSectionIndex` or `traveledDistanceOnLastSection` are provided then\n`lastTraveledSectionIndex` and `traveledDistanceOnLastSection` will be applied first, and\nthen `origin` will be matched to the part of the route that's left. This is the default behavior.\n* `returnToRoute` - Same as `none` if current position is on the route. If the current\nposition is not on the original route then a new route to the destination will be\ncalculated, starting from the current position. The new route will try to preserve the shape\nof the original route, if possible. If a new optimal route is found before a route back to\nthe original route then the new route will be returned.\n",
        "enum": [
          "none",
          "returnToRoute"
        ],
        "type": "string"
      },
      "Return": {
        "description": "Defines which attributes are included in the response as part of data representation of a\n`Route` or `Section`.\n\n* `polyline` - Polyline for the route in [Flexible Polyline](https://github.com/heremaps/flexible-polyline) Encoding.\n   Either a 2D polyline (without `elevation` specified), or a 3D polyline with the 3rd dimension type `Elevation` (with `elevation` specified).\n* `actions` - Actions (such as maneuvers or tasks) that must be taken to complete the section.\n* `instructions` - Include instructions in returned actions. Instructions are localized to the requested language.\n* `summary` - Include summary for the section.\n* `travelSummary` - Include summary for the travel portion of the section.\n* `turnByTurnActions` - Include all information necessary to support turn by turn guidance to complete the section.\n* `mlDuration` - Use a region-specific machine learning model to calculate route duration.\n   **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes.**\n* `typicalDuration` - Include route duration under typical traffic conditions.\n* `elevation` - Include elevation information in coordinate and geometry types. See e.g. `polyline` or `location`.\n* `routeHandle` - Encode calculated route and return a handle which can be used with\n  `routes/{routeHandle}` to decode the route at a later point in time.\n* `passthrough` - Include information on passthrough via waypoints in the section.\n* `incidents` - Include a list of all incidents applicable to each section.\n   Incidents are localized to the requested language.\n   This requires `incidents` to be specified as part of the `return` parameter.\n* `routingZones` - Include information about routing zones each section goes through.\n* `truckRoadTypes` - Include information about road types each section goes through.\n* `tolls` - Include information about the tolls to be paid, per section, according to the `tolls` parameter and other toll-influencing\n  parameters such as vehicle dimensions in the query,\n  e.g `transportMode`, `vehicle[hovOccupancy]`, truck[height]. The full list of toll-related attributes is available in the\n  [Tolls](https://developer.here.com/documentation/routing-api/dev_guide/topics/use-cases/tolls.html) page of the Developer Guide\n  If tolls cannot be calculated for a section, it will contain the `tollsDataUnavailable` notice code.\n  **Note**: some toll-related options such as cars with trailers, or vehicle fuel related tolls are planned but not implemented at the moment.\n  Therefore the request will return the most \"typical\" toll cost.\n* `routeLabels` - Include a list of the most important names and route numbers on this route that differentiate it from other alternatives\nThe following restrictions apply when specifying the `return` parameter:\n\n* If `actions` is requested, then `polyline` must also be requested as well.\n* If `instructions` is requested, then `actions` must also be requested as well.\n* If `turnByTurnActions` is requested, then `polyline` must also be requested as well.\n* If at least one attribute is requested within the `spans` parameter, then `polyline` must be request as well\n",
        "enum": [
          "polyline",
          "actions",
          "instructions",
          "summary",
          "travelSummary",
          "mlDuration",
          "typicalDuration",
          "turnByTurnActions",
          "elevation",
          "routeHandle",
          "passthrough",
          "incidents",
          "routingZones",
          "truckRoadTypes",
          "tolls",
          "routeLabels"
        ],
        "type": "string"
      },
      "RoadInfo": {
        "description": "Road information attached to an offset action",
        "example": {
          "fennstrasse": {
            "name": [
              {
                "language": "de",
                "value": "Fennstraße"
              }
            ],
            "number": [
              {
                "language": "de",
                "value": "B96"
              }
            ],
            "toward": [
              {
                "language": "de",
                "value": "Reinickendorf"
              }
            ],
            "type": "street"
          }
        },
        "properties": {
          "name": {
            "description": "Name of the road\n\nIf the road has multiple names, each name will be a separate entry in the array.\nThe road names can be in multiple languages. If a preferred language was provided,\nand names in that language are available, they will be prioritized in the array.\nOtherwise the default name of the street is prioritized.\n",
            "items": {
              "$ref": "#/components/schemas/LocalizedString"
            },
            "type": "array"
          },
          "number": {
            "description": "Route name or number (e.g. 'M25')",
            "items": {
              "$ref": "#/components/schemas/LocalizedString"
            },
            "type": "array"
          },
          "toward": {
            "description": "Names of destinations on sign which can be reached when going in that direction",
            "items": {
              "$ref": "#/components/schemas/LocalizedString"
            },
            "type": "array"
          },
          "type": {
            "$ref": "#/components/schemas/RoadInfoType"
          }
        }
      },
      "RoadInfoType": {
        "default": "urban",
        "description": "Type of the road (rural, urban, highway)",
        "enum": [
          "rural",
          "urban",
          "highway"
        ],
        "type": "string"
      },
      "RoundaboutEnterAction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/TurnAction"
          }
        ]
      },
      "RoundaboutExitAction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ExitAction"
          }
        ]
      },
      "RoundaboutPassAction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/TurnAction"
          }
        ]
      },
      "RouteLabel": {
        "oneOf": [
          {
            "description": "Designated name of the road (e.g. a street name or a transport name)",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/LocalizedString"
              }
            }
          },
          {
            "description": "Designated route name or number of the road (e.g. 'M25')",
            "properties": {
              "routeNumber": {
                "$ref": "#/components/schemas/LocalizedString"
              }
            }
          }
        ]
      },
      "RouteResponseNotice": {
        "description": "A notice contains important notifications.",
        "example": {
          "$ref": "#/components/examples/routeResponseNoticeExample"
        },
        "properties": {
          "code": {
            "description": "Extensible enum: `noRouteFound` `failedRouteHandleCreation` `cancelled` `routeCalculationFailed` `couldNotMatchOrigin` `couldNotMatchDestination` `violatedTransportModeInRouteHandleDecoding` `unknownError` `routeLengthLimitExceeded` `avoidSegmentsInvalidId` `avoidZonesInvalidId` `returnToRoute` `importFailed` `importSplitRoute` `...`  \nCurrently known codes (non-exhaustive: this list could be extended for new error situations):\n\n| Code      | Description  | Severity |\n| --------- | ------- | ------- |\n| noRouteFound | No Route was found | critical |\n| failedRouteHandleCreation | No RouteHandle was created | critical |\n| cancelled | Calculation took too long and was cancelled | critical |\n| routeCalculationFailed | Calculation did not succeed | critical |\n| couldNotMatchOrigin | Origin waypoint could not be matched | critical |\n| couldNotMatchDestination | Destination waypoint could not be matched | critical |\n| noReachableChargingStationsFound | Initial charge is not enough to reach any known charging stations | critical |\n| violatedTransportModeInRouteHandleDecoding | Route handle decoding failed due to forbidden segments for the specified transport mode | critical |\n| unknownError | No detailed error cause has been determined | critical |\n| routeLengthLimitExceeded | Distance between waypoints is too large for current options | critical |\n| avoidSegmentsInvalidId | The provided segment ID was not found | info |\n| avoidZonesInvalidId | The provided zone ID was not found | info |\n| returnToRoute | Applicable only to requests with route handle provided. Current route position was not on the original route. New route was calculated from the current position to the destination. Old route may have been reused. | info |\n| importFailed | No route section was found for imported waypoints | critical |\n| importSplitRoute | Not all trace points were matched | info |\n",
            "example": "noRouteFound",
            "type": "string",
            "x-extensible-enum": [
              "noRouteFound",
              "failedRouteHandleCreation",
              "cancelled",
              "routeCalculationFailed",
              "couldNotMatchOrigin",
              "couldNotMatchDestination",
              "violatedTransportModeInRouteHandleDecoding",
              "unknownError",
              "routeLengthLimitExceeded",
              "avoidSegmentsInvalidId",
              "avoidZonesInvalidId",
              "returnToRoute",
              "importFailed",
              "importSplitRoute"
            ]
          },
          "details": {
            "description": "Additional details about the notice",
            "items": {
              "$ref": "#/components/schemas/BaseNoticeDetail"
            },
            "type": "array"
          },
          "severity": {
            "$ref": "#/components/schemas/NoticeSeverity"
          },
          "title": {
            "description": "Human-readable notice description.",
            "example": "No route found",
            "type": "string"
          }
        },
        "required": [
          "code"
        ]
      },
      "RouterMode": {
        "description": "Mode of transport to be used for route calculation.",
        "enum": [
          "car",
          "truck",
          "pedestrian",
          "bicycle",
          "scooter",
          "taxi",
          "bus",
          "privateBus"
        ],
        "type": "string"
      },
      "RouterRoute": {
        "description": "A basic route. Includes personal vehicles as car, truck, etc... For all modes, cf. `transportMode`.\n",
        "properties": {
          "id": {
            "description": "Unique identifier of the route",
            "type": "string"
          },
          "notices": {
            "description": "Contains a list of issues encountered during the processing of this response.",
            "items": {
              "$ref": "#/components/schemas/Notice"
            },
            "type": "array"
          },
          "routeHandle": {
            "description": "Opaque handle of the calculated route.\n\nA handle encodes the calculated route. The route can be decoded from a handle at a\nlater point in time as long as the service uses the same map data which was used\nduring encoding.\n\nTo request a handle set the `routeHandle` flag in `return` parameter. If a handle is\nrequested, but fails to be calculated for any reason, then the `routeHandle` property is\nnot available in the response. The rest of the route is intact.\n",
            "type": "string"
          },
          "routeLabels": {
            "description": "Contains a list of the most important names and route numbers on this route that differentiate it from other alternatives.\nThese names are used to make labels for the main and alternative routes, like \"route1 via A4,D10\", \"route2 via D11,5\"\nThe generated list is expected to be unique for each route in response (but it's not guaranteed)\n",
            "items": {
              "$ref": "#/components/schemas/RouteLabel"
            },
            "maxItems": 2,
            "minItems": 0,
            "type": "array"
          },
          "sections": {
            "description": "An ordered list of vehicle, transit, and pedestrian sections making up the route.\n",
            "items": {
              "$ref": "#/components/schemas/RouterSection"
            },
            "type": "array"
          }
        },
        "required": [
          "id",
          "sections"
        ]
      },
      "RouterRouteResponse": {
        "description": "Returns a list of routes.",
        "properties": {
          "notices": {
            "description": "Contains a list of issues related to this route calculation.\nPlease refer to the `code` attribute for possible values.\n",
            "items": {
              "$ref": "#/components/schemas/RouteResponseNotice"
            },
            "type": "array"
          },
          "routes": {
            "description": "List of possible routes",
            "items": {
              "$ref": "#/components/schemas/RouterRoute"
            },
            "type": "array"
          }
        },
        "required": [
          "routes"
        ]
      },
      "RouterSection": {
        "description": "One of the possible sections that can be part of the Router route.\n\n`TransitSection` is only used for ferries and car shuttles.\n",
        "discriminator": {
          "mapping": {
            "pedestrian": "#/components/schemas/PedestrianSection",
            "transit": "#/components/schemas/TransitSection",
            "vehicle": "#/components/schemas/VehicleSection"
          },
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/VehicleSection"
          },
          {
            "$ref": "#/components/schemas/PedestrianSection"
          },
          {
            "$ref": "#/components/schemas/TransitSection"
          }
        ]
      },
      "Routing403ErrorResponseSchema": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/AuthErrorResponseSchema"
          },
          {
            "$ref": "#/components/schemas/RoutingErrorResponse"
          }
        ]
      },
      "RoutingErrorResponse": {
        "description": "Response in case of error",
        "properties": {
          "action": {
            "description": "Human-readable description of the action that can be taken to correct the error",
            "example": "Request a valid id",
            "type": "string"
          },
          "cause": {
            "description": "Human-readable explanation for the error",
            "example": "The input data in question does not comply with validation rules",
            "type": "string"
          },
          "code": {
            "description": "Machine readable service error code.\n\nAll error codes of this service start with \"`E605`\". The last three digits describe a specific error. Provide this error code when contacting support.\n\n**NOTE:** Please note that the list of possible error codes could be extended in the future. The client application is expected to handle such a case gracefully.\n\n| Code      | Reason  |\n| --------- | ------- |\n| `E60500X` | Malformed query. Typically due to invalid values such as `transportMode=spaceShuttle` or missing required fields. Check the error message for details. |\n| `E605010` | Invalid combination of vehicle options and transport mode. |\n| `E605011` | Invalid combination of avoid feature `difficultTurns` or `uTurns` and transport mode. Check `avoid` for details. |\n| `E605012` | Invalid combination of transport mode and routing mode. Check `routingMode` for a list of supported combinations. |\n| `E605013` | Invalid return options. Check `return` for valid combinations of values. |\n| `E605014` | Invalid language code. Check `lang` for details on how valid language codes look. |\n| `E605015` | Too many alternatives. Check `alternatives` for the maximum number of alternatives allowed. |\n| `E605016` | Invalid exclude countries. Check `exclude` for details. |\n| `E605017` | `spans` contains a value whose dependency has not been requested |\n| `E605018` | Invalid combination of departure and arrival time |\n| `E605019` | `truck[weightPerAxle]` and `truck[weightPerAxleGroup]` are incompatible |\n| `E605020` | Invalid combination of `radius` and `snapRadius`  |\n| `E605030` | Invalid EV options. Check `ev` for details on how valid EV options look. |\n| `E605032` | Invalid transport mode for speed cap, check `vehicle[speedCap]` for details. |\n| `E605033` | Invalid combination of scooter and transport mode. Check `scooter` for valid scooter transport modes. |\n| `E605034` | Invalid Speed Cap, check `vehicle[speedCap]` for details. |\n| `E605035` | MLDuration is not supported with `vehicle[speedCap]` parameter. |\n| `E605040` | Invalid combination of EV and transport mode. Check `ev` for details. |\n| `E605041` | Invalid combination of EV and routing mode. Check `ev` for details. |\n| `E605042` | Invalid combination of EV and alternatives. Check `ev` for details. |\n| `E605043` | Invalid combination of EV and avoid options. Check `ev` for details. |\n| `E605047` | Invalid combination of EV and arrival time. Check `ev` for details. |\n| `E605048` | Invalid combination of avoid feature `difficultTurns` and truck category `lightTruck`. |\n| `E605052` | Invalid number of trace points. Check `MatchTrace` for the minimum and maximum number of trace points allowed. |\n| `E605053` | Invalid Match trace via. Check `via` in `MatchTrace` for valid indexes. |\n| `E605054` | Too many avoid areas. Check `areas` for the maximum number of avoid areas allowed. |\n| `E605055` | Invalid trailer axle count. |\n| `E605056` | Too many avoid polygons. Check `areas[polygon]` for the maximum number of polygons allowed. |\n| `E605057` | Too many vertices in the polygon. Check `areas[polygon]` for the maximum number of vertices allowed. |\n| `E605058` | Not enough vertices in the polygon. Check `areas[polygon]` for the minimum number of vertices allowed. |\n| `E605059` | Polygon is self-intersecting. Check `areas[polygon]`. |\n| `E605075` | Invalid customizationIndex. |\n| `E605101` | Credentials not allowed for calculating routes in Japan. |\n| `E605201` | RouteHandle not valid (anymore). (Re-)calculate route to retrieve new handle. |\n| `E605301` | Pedestrian options are only supported for transport mode `pedestrian`. |\n| `E605302` | Routing zones is not supported for transport mode `pedestrian`. |\n| `E605303` | Avoiding routing zones is not supported for transport mode `pedestrian`. |\n| `E605304` | Avoiding truck road types is not supported for transport mode `pedestrian`. |\n| `E605400` | Customization not supported. |\n| `E6055XX` | Internal server error. |\n",
            "example": "E605001",
            "type": "string"
          },
          "correlationId": {
            "description": "Auto-generated id that univocally identifies the request",
            "example": "4199533b-6290-41db-8d79-edf4f4019a74",
            "type": "string"
          },
          "status": {
            "description": "HTTP status code",
            "example": 400,
            "type": "integer"
          },
          "title": {
            "description": "Human-readable error description",
            "example": "Input data failed validation",
            "type": "string"
          }
        },
        "required": [
          "title",
          "status",
          "code",
          "cause",
          "action",
          "correlationId"
        ]
      },
      "RoutingMode": {
        "default": "fast",
        "description": "Specifies which optimization is applied during route calculation.\n\n* `fast`: Route calculation from start to destination optimized by travel time. In many\n  cases, the route returned by the `fast` mode may not be the route with the fastest\n  possible travel time. For example, the routing service may favor a route that remains on\n  a highway, even if a faster travel time can be achieved by taking a detour or shortcut\n  through an inconvenient side road.\n* `short`: Route calculation from start to destination disregarding any speed information.\n  In this mode, the distance of the route is minimized, while keeping the route sensible.\n  This includes, for example, penalizing turns. Because of that, the resulting route will\n  not necessarily be the one with minimal distance.\n\nNotes:\n* The following Transport modes only support `fast` routingMode\n  - `bicycle`\n  - `bus`\n  - `pedestrian`\n  - `privateBus`\n  - `scooter`\n  - `taxi`\n",
        "enum": [
          "fast",
          "short"
        ],
        "type": "string"
      },
      "RoutingZone": {
        "description": "Information about a routing zone.",
        "properties": {
          "name": {
            "description": "The routing zone's name.",
            "type": "string"
          },
          "ref": {
            "description": "A reference to a routing zone in HMC.\n\nThe standard representation of a routing zone reference has the following structure:\n`{catalogHrn}:{catalogVersion}:({layerId})?:{tileId}:{zoneId}`\n\nThe individual parts are:\n* `catalogHrn`: The HERE Resource Name that identifies the source catalog of the routing zone, example: `hrn:here:data::olp-here:rib-2`\n* `catalogVersion`: The catalog version\n* `layerId` (optional): The layer inside the catalog where the routing zone is located, example: `environmental-zones`\n* `tileId`: The HERE tile key of the partition/tile where the routing zone is located in the given version of the catalog\n* `zoneId`: The identifier of the referenced routing zone within the catalog, example: `here:cm:envzone:3455277`\n\nExample of a reference to an environmental zone in standard form:\n`hrn:here:data::olp-here:rib-2:1557:environmental-zones:all:here:cm:envzone:3455277`\n\nIn order to reduce reponse size, routing zone references can also be provided in a compact representation.\nIn compact form, parts of a reference are replaced by placeholders, which can be resolved using the `refReplacements` dictionary in the parent section.\nThe placeholder format is ```\\$\\d+``` and needs to be surrounded by colons or string start/end. It can be captured with the following regular expression: ```(^|:)\\$\\d+(:|$)``` .\n\nExample of the aforementioned environmental zone reference in compact form: `$0:$1:3455277`\nWith the corresponding `refReplacements`:\n```\n\"refReplacements\": {\n  \"0\": \"hrn:here:data::olp-here:rib-2:1557\",\n  \"1\": \"environmental-zones:all:here:cm:envzone\"\n}\n```\n",
            "type": "string"
          },
          "type": {
            "description": "Extensible enum: `environmental` `vignette` `...`  \nThe type of a routing zone.\n",
            "type": "string",
            "x-extensible-enum": [
              "environmental",
              "vignette"
            ]
          }
        }
      },
      "Scooter": {
        "description": "Scooter specific parameters",
        "properties": {
          "allowHighway": {
            "default": false,
            "description": "Specifies whether scooter is allowed on highway or not. This parameter is optional. If not provided, then by default scooter is not allowed to use highway. There is a similar parameter avoid[features]=controlledAccessHighway to disallow highway usage. avoid[features] takes precedence so if this parameter is also used then scooters are not allowed to use highways even if `allowHighway` is used with value as true.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "SinglePrice": {
        "properties": {
          "currency": {
            "description": "Local currency of the price compliant to ISO 4217",
            "type": "string"
          },
          "estimated": {
            "default": false,
            "description": "Attribute value is `true` if the fare price is estimated, `false` if it is an exact value.",
            "type": "boolean"
          },
          "type": {
            "description": "Type of price represented by this object. The API customer is responsible for correctly visualizing\nthe pricing model. As it is possible to extend the supported price types in the future,\nthe price information should be hidden when an unknown type is encountered.\n\nAvailable price types are:\n\n  * `value` - A single value.\n  * `range` - A range value that includes a minimum and maximum price.\n",
            "type": "string"
          },
          "unit": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "When set, the price is paid for a specific duration.\n\nExamples:\n  * `\"unit\": 3600` - price for one hour\n  * `\"unit\": 28800` - price for 8 hours\n  * `\"unit\": 86400` - price for one day\n"
          },
          "value": {
            "description": "The price value",
            "type": "number"
          }
        },
        "required": [
          "type",
          "currency",
          "value"
        ]
      },
      "Spans": {
        "enum": [
          "walkAttributes",
          "streetAttributes",
          "carAttributes",
          "truckAttributes",
          "scooterAttributes",
          "names",
          "length",
          "duration",
          "baseDuration",
          "typicalDuration",
          "countryCode",
          "stateCode",
          "functionalClass",
          "routeNumbers",
          "speedLimit",
          "maxSpeed",
          "dynamicSpeedInfo",
          "segmentId",
          "segmentRef",
          "consumption",
          "routingZones",
          "truckRoadTypes",
          "notices",
          "incidents",
          "tollSystems"
        ],
        "type": "string"
      },
      "Speed": {
        "description": "Speed in meters per second",
        "minimum": 0,
        "type": "number"
      },
      "StateCode": {
        "description": "ISO-3166-2 code.\nUsed for identifying the principal subdivisions (e.g., provinces or states) of a country with some `CountryCode`.\nMade of up to three alphanumeric characters.\n\nPreferably used in conjunction with the `CountryCode`.\nState code is available in the following countries:\n  - USA\n  - Canada\n  - Australia\n  - China\n  - India\n",
        "type": "string"
      },
      "StationPlace": {
        "description": "A station",
        "properties": {
          "code": {
            "description": "Short text or a number that identifies the place for riders.",
            "type": "string"
          },
          "id": {
            "description": "Identifier of this station",
            "type": "string"
          },
          "location": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Location"
              }
            ],
            "description": "The position of this location\n\nThis position was used in route calculation. It may be different to the original position provided in the request.\n"
          },
          "name": {
            "description": "Location name",
            "type": "string"
          },
          "originalLocation": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Location"
              }
            ],
            "description": "If present, the original position of this location provided in the request."
          },
          "platform": {
            "description": "Platform name or number for the departure.",
            "type": "string"
          },
          "type": {
            "description": "Place type. Each place type can have extra attributes.\n\n**NOTE:** The list of possible place types could be extended in the future.\nThe client application is expected to handle such a case gracefully.\n",
            "type": "string"
          },
          "waypoint": {
            "description": "If present, this place corresponds to the waypoint in the request with the same index.",
            "type": "integer"
          },
          "wheelchairAccessible": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WheelchairAccessibility"
              }
            ],
            "description": "Information about accessibility for people with a disability and who use a wheelchair.\n\n* `unknown` - Accessibility information is not available.\n* `yes` - There exists some accessible path from outside the station to the specific stop/platform.\n* `limited` - Accessibility is limited or assistance is required.\n* `no` - There exists no accessible path from outside the station to the specific stop/platform.\n"
          }
        },
        "required": [
          "type",
          "location"
        ]
      },
      "StreetAttributes": {
        "description": "Extensible enum: `rightDrivingSide` `dirtRoad` `tunnel` `bridge` `ramp` `controlledAccess` `roundabout` `underConstruction` `dividedRoad` `privateRoad` `...`  \n`StreetAttributes` is applied to a span of a route section and describes attribute flags of a street.\n* `rightDrivingSide`: Do vehicles have to drive on the right-hand side of the road or the left-hand side.\n* `dirtRoad`: This part of the route has an un-paved surface.\n* `tunnel`: This part of the route is a tunnel.\n* `bridge`: This part of the route is a bridge.\n* `ramp`: This part of the route is a ramp (usually connecting to/from/between highways).\n* `motorway`: This part of the route is a controlled access road (usually highways with motorway sign).\n* `roundabout`: This part of the route is a roundabout.\n* `underConstruction`: This part of the route is under construction.\n* `dividedRoad`: This part of the route uses a road with a physical or legal divider in the middle.\n* `privateRoad`: This part of the route uses a privately owned road.\n* `controlledAccessHighway`: This part of the route is a either controlled access or limited access road or both.\n\nAs it is possible that new street attributes are supported in the future, unknown street attributes should be ignored.\n",
        "type": "string",
        "x-extensible-enum": [
          "rightDrivingSide",
          "dirtRoad",
          "tunnel",
          "bridge",
          "ramp",
          "controlledAccess",
          "roundabout",
          "underConstruction",
          "dividedRoad",
          "privateRoad"
        ]
      },
      "Taxi": {
        "description": "Taxi specific parameters",
        "properties": {
          "allowDriveThroughTaxiRoads": {
            "default": true,
            "description": "Specifies if a vehicle is allowed to drive through taxi-only roads and lanes. Even if\nthis option is set to false, the vehicle is still allowed on taxi-only roads at the\nstart of the route and at the destination.\n\n**Disclaimer**: This parameter is currently provided as Beta with limited functionality.\n",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "Time": {
        "description": "**RFC 3339**, section 5.6 as defined by either `date-time` or `date-only` 'T' `partial-time` (ie no time-offset).",
        "format": "date-time",
        "type": "string"
      },
      "TimeRestrictedPrice": {
        "properties": {
          "currency": {
            "description": "Local currency of the price compliant to ISO 4217",
            "type": "string"
          },
          "days": {
            "description": "This price applies only for the selected days",
            "example": [
              "sa",
              "su"
            ],
            "items": {
              "$ref": "#/components/schemas/TimeRestrictedWeekdays"
            },
            "type": "array"
          },
          "estimated": {
            "default": false,
            "description": "Attribute value is `true` if the fare price is estimated, `false` if it is an exact value.",
            "type": "boolean"
          },
          "fromTime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PartialTime"
              }
            ],
            "description": "The price applies from this time of the day"
          },
          "maxDuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "The price applies if the duration is less or equal to `maxDuration`",
            "example": 3600
          },
          "minDuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "The price applies if the duration is more or equal to `minDuration`",
            "example": 1801
          },
          "toTime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PartialTime"
              }
            ],
            "description": "The price applies until this time of the day"
          },
          "type": {
            "description": "Type of price represented by this object. The API customer is responsible for correctly visualizing\nthe pricing model. As it is possible to extend the supported price types in the future,\nthe price information should be hidden when an unknown type is encountered.\n\nAvailable price types are:\n\n  * `restricted` - A single price value valid for a specific time or duration\n",
            "type": "string"
          },
          "unit": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "When set, the price is paid for a specific duration.\n\nExamples:\n  * `\"unit\": 3600` - price for one hour\n  * `\"unit\": 28800` - price for 8 hours\n  * `\"unit\": 86400` - price for one day\n"
          },
          "value": {
            "description": "The price value",
            "type": "number"
          }
        },
        "required": [
          "type",
          "currency",
          "value"
        ]
      },
      "TimeRestrictedWeekdays": {
        "enum": [
          "mo",
          "tu",
          "we",
          "th",
          "fr",
          "sa",
          "su"
        ],
        "type": "string"
      },
      "TimeWithAny": {
        "description": "Specifies the time either as\n\n* \"**RFC 3339**, section 5.6 as defined by either `date-time` or `date-only` 'T'\n`partial-time` (ie no time-offset)\", or\n* the special value `any` which stand for unspecified time\n",
        "type": "string"
      },
      "TollCollectionLocation": {
        "description": "Location of the physical toll structure used for the toll collection.\nTypically, this would be a toll booth, but it may also be a transponder reader or a number-plate camera.\nTolls that are paid via a vignette, for example, do not have toll collection locations, and therefore this element\nwould not be present at all.\n\nThe value of this property is a `Location` specifying the coordinates of the payment location.\n",
        "properties": {
          "location": {
            "$ref": "#/components/schemas/Location"
          },
          "name": {
            "description": "Descriptive name of the location.\n",
            "type": "string"
          }
        },
        "required": [
          "location"
        ]
      },
      "TollCost": {
        "description": "Information for a single toll payment.\n",
        "properties": {
          "countryCode": {
            "$ref": "#/components/schemas/CountryCode"
          },
          "fares": {
            "description": "List of possible `Fare`s to pay, which may depend on time of day, payment method, vehicle characteristics, etc.\n\n**Note**: The router presents only options relevant to the original query, on a best effort basis.\nNote that a `Fare` for tolls is always a `SinglePrice`.\n",
            "items": {
              "$ref": "#/components/schemas/Fare"
            },
            "type": "array"
          },
          "tollCollectionLocations": {
            "description": "Information about the location(s) of the toll places where the fare is collected. In case of entry/exit tolls\nmeasured by distance, both entry and exit toll locations are returned. Note that since payment is at only one of\nthese places (normally the exit), the other place *may* be in an unrelated section.\n",
            "items": {
              "$ref": "#/components/schemas/TollCollectionLocation"
            },
            "type": "array"
          },
          "tollSystem": {
            "deprecated": true,
            "description": "Name of the toll system collecting the toll.\n",
            "type": "string"
          },
          "tollSystemRef": {
            "description": "Reference index of the affected toll system in the `tollSystems` array.\n",
            "type": "integer"
          }
        },
        "required": [
          "tollSystem",
          "tollSystemRef",
          "fares"
        ]
      },
      "TollCountrySummary": {
        "properties": {
          "countryCode": {
            "$ref": "#/components/schemas/CountryCode"
          },
          "price": {
            "$ref": "#/components/schemas/FarePrice"
          }
        }
      },
      "TollSummary": {
        "description": "Summary of the tolls grouped by criteria (total, per system, per country)\n",
        "properties": {
          "total": {
            "$ref": "#/components/schemas/FarePrice",
            "description": "Total toll to be paid for the section, in the requested currency.\n"
          },
          "totalByCountry": {
            "description": "Total tolls to be paid in the section, grouped per country.\n",
            "items": {
              "$ref": "#/components/schemas/TollCountrySummary"
            },
            "type": "array"
          },
          "totalBySystem": {
            "description": "Total tolls to be paid in the section, grouped per toll system.\n",
            "items": {
              "$ref": "#/components/schemas/TollSystemSummary"
            },
            "type": "array"
          }
        }
      },
      "TollSystem": {
        "description": "Information about a toll system collecting payments on the route.\n",
        "properties": {
          "name": {
            "description": "Name of this toll system\n",
            "type": "string"
          },
          "ref": {
            "description": "Internal identification of this toll system. Will be replaced in the future by an hrn identifier.\n",
            "type": "string"
          }
        }
      },
      "TollSystemSummary": {
        "properties": {
          "price": {
            "$ref": "#/components/schemas/FarePrice"
          },
          "tollSystem": {
            "description": "Reference index into the `tollSystems` array of the containing section.\n",
            "type": "integer"
          }
        }
      },
      "Tolls": {
        "description": "Vehicle-independent options that may affect route toll calculation as well as options\naffecting the output of the tolls, such as summaries.\n\nSince this parameter controls behaviour related to tolls in the return part of the response,\nuse of this parameter requires `return=tolls` to be selected.\n",
        "properties": {
          "emissionType": {
            "description": "Extensible enum: `euro1` `euro2` `euro3` `euro4` `euro5` `euro6` `euroEev` `...`  \nDefines the emission classes as defined by the toll operator. The types defined are based on the Emission standards. Emission types are only published when the toll cost is defined based on emission classes.\n\n**NOTE:** This parameter is not compatible with EV routing: When EV routing is used, the appropriate emission type (Electric Vehicle) is used.\n",
            "type": "string",
            "x-extensible-enum": [
              "euro1",
              "euro2",
              "euro3",
              "euro4",
              "euro5",
              "euro6",
              "euroEev"
            ]
          },
          "summaries": {
            "description": "Items extensible enum: `total` `tollSystem` `country` `...`  \nThis parameter allows the user to specify criteria for tolls aggregation.\nMultiple values may be requested at once.\nToll aggregation is performed at the section level only.\n\nPossible values are:\n  - `total`: the user wants a single value summarizing the tolls to be paid in the section.\n    This summary criterion requires that a `currency` has been passed as a parameter, to group\n    multi-currency roads together, even if the route would traverse roads that use only one currency;\n    see `currency` parameter.\n  - `tollSystem`: toll costs are aggregated per toll system.\n  - `country`: toll costs are aggregated per country.\n\nNote that any toll instance may have multiple prices, depending on factors such as time of day,\npayment methods, etc. that are not available in the request. As a result,\nthe most economical value is selected for summary calculation, so summaries should be considered\ninformative only.\n",
            "items": {
              "type": "string",
              "x-extensible-enum": [
                "total",
                "tollSystem",
                "country"
              ]
            },
            "type": "array"
          },
          "transponders": {
            "description": "This parameter allows the user to specify for which systems the user has valid transponders.\nIf a toll requires a certain transponder and the user states they have that transponder,\nno notices will be given regarding the requirement to have it.\nAdditionally, the price for payment with transponders will be used when reporting fare prices\nand summaries, if required by the `tolls[summaries]` parameter.\n\nThe value of the parameter is a comma-separated list of transponder systems that the user has. Alternatively,\nthe user can also specify `all` as a list element to state they have all required transponders along any potential route.\n\n**Note**: currently, the only valid value is `all`.\n",
            "type": "string"
          },
          "vehicleCategory": {
            "description": "Extensible enum: `minibus` `...`  \nDefines special toll vehicle types. Usual types like car or truck are determined from transport mode.\n\n| category  | Description |\n| --------- | ------- |\n| minibus | Commercial buses with a seating capacity of 16-25 passengers (NA) or a small bus that is used to transport a maximum of 15 passengers. Can be used only with transport mode `car` |\n\n**NOTE:** It can be extended by other vehicle categories in the future.\n",
            "type": "string",
            "x-extensible-enum": [
              "minibus"
            ]
          },
          "vignettes": {
            "description": "This parameter allows the user to specify for which toll roads the user has valid vignettes.\nIf a road requires a certain vignette and the user states that they have it, no notices will be\ngiven regarding the requirement to have it.\n\nThe value of the parameter is a comma-separated list of vignettes that the user has. Alternatively,\nthe user can also specify `all` as a list element to state they have all required vignettes along any potential route.\n\nNo toll costs information will be returned for a given road requiring a vignette if the user states\nthey already have it, as no further payment is necessary. If `tolls` are requested for spans, the toll\nsections for these types of toll systems are still reported, nevertheless.\n\n**Note**: currently, the only valid value is `all`.\n",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Traffic": {
        "description": "Traffic specific parameters.",
        "properties": {
          "overrideFlowDuration": {
            "description": "Duration in seconds for which flow traffic event would be considered valid. While flow\ntraffic event is valid it will be used over the historical traffic data.\n\n**Note**: Flow traffic represents congestion not caused by any long-term incidents.\nState of the flow traffic often changes fast. The farther away from the current time we\nmove, the less precise current flow traffic data will be and the more precise historical\ntraffic data becomes. That's why it's advised not to use this parameter unless you know\nwhat you want to achieve and use the default behavior which is almost always better.\n",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "TrafficIncident": {
        "description": "An incident describes a temporary event on the road network.\nIt typically refers to a real world incident (accident, road construction, weather condition, etc.)\non a street or street segment\n",
        "properties": {
          "criticality": {
            "$ref": "#/components/schemas/TrafficIncidentCriticality"
          },
          "description": {
            "description": "A human readable description of the incident",
            "example": "closed due to roadworks",
            "type": "string"
          },
          "id": {
            "description": "Traffic Incident unique identifier,\n\nExample of a incident identifier in standard representation:\nhere:traffic:incident:1000155780078589348\n\nId usage:\nAn incident details can be queried from traffic service later, see\nhttps://developer.here.com/documentation/traffic-api/dev_guide/topics/use-cases/incidents-by-id.html\n\n**Notice**:\nIn most cases, the ID comes from a third party incident supplier.\nThis means that once an incident has expired, the ID might be reused\n",
            "type": "string"
          },
          "type": {
            "$ref": "#/components/schemas/TrafficIncidentType"
          },
          "validFrom": {
            "$ref": "#/components/schemas/Time"
          },
          "validUntil": {
            "$ref": "#/components/schemas/Time"
          }
        }
      },
      "TrafficIncidentCriticality": {
        "description": "Describes the impact an incident has on the route.\n* critical - The part of the route the incident affects is not usable.\n* major - Major impact on duration, e.g. stop and go\n* minor - Minor impact on duration, e.g. traffic jam\n* low - Very little impact on duration, e.g. slightly increased traffic\n",
        "enum": [
          "critical",
          "major",
          "minor",
          "low"
        ],
        "type": "string"
      },
      "TrafficIncidentType": {
        "description": "Extensible enum: `accident` `congestion` `construction` `disabledVehicle` `massTransit` `plannedEvent` `roadHazard` `roadClosure` `weather` `laneRestriction` `other` `...`  \nAn open list of possible incident causes / types.\nNote: Since new types are expected to appear, it is important to check for unknown types when parsing this value.\n",
        "type": "string",
        "x-extensible-enum": [
          "accident",
          "congestion",
          "construction",
          "disabledVehicle",
          "massTransit",
          "plannedEvent",
          "roadHazard",
          "roadClosure",
          "weather",
          "laneRestriction",
          "other"
        ]
      },
      "TrailerCountRange": {
        "description": "Constrains the restriction to vehicles with number of trailers within specified range.",
        "properties": {
          "from": {
            "description": "Inclusive minimum of trailer count.",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "to": {
            "description": "Inclusive maximum of trailer count. If not set, maximum trailer count is unbounded.",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          }
        }
      },
      "TransitDeparture": {
        "description": "Transit departure",
        "properties": {
          "delay": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DepartureDelay"
              }
            ],
            "description": "The accumulated delay in seconds from the scheduled time of the event."
          },
          "place": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StationPlace"
              }
            ],
            "description": "Departure/arrival location"
          },
          "status": {
            "$ref": "#/components/schemas/DepartureStatus"
          },
          "time": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Time"
              }
            ],
            "description": "Expected time of departure of the event. Format is **RFC 3339**, section 5.6 as defined by `date-time`."
          }
        },
        "required": [
          "place"
        ]
      },
      "TransitIncident": {
        "description": "An incident describes disruptions on the transit network.\nDisruptions scale from delays to service cancellations.\n",
        "properties": {
          "description": {
            "description": "A human readable description of the incident",
            "example": "The subway is closed each night between 1 AM and 5 AM while we clean our trains and stations. We are running extra bus service overnight.",
            "type": "string"
          },
          "effect": {
            "$ref": "#/components/schemas/TransitIncidentEffect"
          },
          "summary": {
            "description": "A human readable summary of the incident",
            "example": "The subway is closed each night between 1 AM and 5 AM.",
            "type": "string"
          },
          "type": {
            "$ref": "#/components/schemas/TransitIncidentType"
          },
          "url": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Uri"
              }
            ],
            "description": "Link to the original incident published at the agency website"
          },
          "validFrom": {
            "$ref": "#/components/schemas/Time"
          },
          "validUntil": {
            "$ref": "#/components/schemas/Time"
          }
        },
        "required": [
          "type",
          "effect"
        ]
      },
      "TransitIncidentEffect": {
        "description": "Extensible enum: `cancelledService` `reducedService` `additionalService` `modifiedService` `delays` `detour` `stopMoved` `other` `...`  \nAn open list of possible incident effects.\nNote: Since new types are expected to appear, it is important to check for unknown types when parsing this value.\n",
        "type": "string",
        "x-extensible-enum": [
          "cancelledService",
          "reducedService",
          "additionalService",
          "modifiedService",
          "delays",
          "detour",
          "stopMoved",
          "other"
        ]
      },
      "TransitIncidentType": {
        "description": "Extensible enum: `technicalProblem` `strike` `demonstration` `accident` `holiday` `weather` `maintenance` `construction` `policeActivity` `medicalEmergency` `other` `...`  \nAn open list of possible incident causes / types.\nNote: Since new types are expected to appear, it is important to check for unknown types when parsing this value.\n",
        "type": "string",
        "x-extensible-enum": [
          "technicalProblem",
          "strike",
          "demonstration",
          "accident",
          "holiday",
          "weather",
          "maintenance",
          "construction",
          "policeActivity",
          "medicalEmergency",
          "other"
        ]
      },
      "TransitModeOutput": {
        "description": "Extensible enum: `highSpeedTrain` `intercityTrain` `interRegionalTrain` `regionalTrain` `cityTrain` `bus` `ferry` `subway` `lightRail` `privateBus` `inclined` `aerial` `busRapid` `monorail` `carShuttleTrain` `flight` `spaceship` `...`  \nTransit mode of transport in the route response\n",
        "title": "Modes",
        "type": "string",
        "x-extensible-enum": [
          "highSpeedTrain",
          "intercityTrain",
          "interRegionalTrain",
          "regionalTrain",
          "cityTrain",
          "bus",
          "ferry",
          "subway",
          "lightRail",
          "privateBus",
          "inclined",
          "aerial",
          "busRapid",
          "monorail",
          "carShuttleTrain",
          "flight",
          "spaceship"
        ]
      },
      "TransitNotice": {
        "description": "A notice contains important notifications.",
        "properties": {
          "code": {
            "description": "Extensible enum: `noSchedule` `noIntermediate` `unwantedMode` `scheduledTimes` `simplePolyline` `violatedAvoidFerry` `violatedAvoidTrainFerry` `...`  \nCurrently known codes (non-exhaustive: this list could be extended for new situations):\n\n| Code      | Description  | Severity |\n| ------            | ------- | ------- |\n| noSchedule | A timetable schedule is not available for the transit line in this section, and only the run frequency is available. As a result, departure/arrival times are approximated | info |\n| noIntermediate | Information about intermediate stops is not available for this transit line | info |\n| unwantedMode | This section contains a transport mode that was explicitly disabled. Mode filtering is not available in this area | info |\n| scheduledTimes | The times returned on this section are the scheduled times even though delay information are available | info |\n| simplePolyline | An accurate polyline is not available for this section. The returned polyline has been generated from departure and arrival places | info |\n| violatedAvoidFerry | Route did not manage to avoid user preference | critical |\n| violatedAvoidTrainFerry | Route did not manage to avoid user preference | critical |\n",
            "example": "noSchedule",
            "type": "string",
            "x-extensible-enum": [
              "noSchedule",
              "noIntermediate",
              "unwantedMode",
              "scheduledTimes",
              "simplePolyline",
              "violatedAvoidFerry",
              "violatedAvoidTrainFerry"
            ]
          },
          "details": {
            "description": "Additional details about the notice",
            "items": {
              "$ref": "#/components/schemas/BaseNoticeDetail"
            },
            "type": "array"
          },
          "severity": {
            "$ref": "#/components/schemas/NoticeSeverity"
          },
          "title": {
            "description": "Human-readable notice description.",
            "example": "No schedule",
            "type": "string"
          }
        },
        "required": [
          "code"
        ]
      },
      "TransitPostAction": {
        "discriminator": {
          "mapping": {
            "deboard": "#/components/schemas/DeboardAction"
          },
          "propertyName": "action"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/DeboardAction"
          }
        ]
      },
      "TransitPreAction": {
        "description": "An action that must be done prior to `departure`.",
        "discriminator": {
          "mapping": {
            "board": "#/components/schemas/BoardAction"
          },
          "propertyName": "action"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/BoardAction"
          }
        ]
      },
      "TransitSection": {
        "description": "A section of the route. It contains departure, arrival, and route information.",
        "properties": {
          "actions": {
            "description": "Actions that must be done during the travel portion of the section, i.e., between `departure` and `arrival`.\n\n*NOTE:* currentRoad and nextRoad are not populated for actions.\n",
            "items": {
              "$ref": "#/components/schemas/OffsetAction"
            },
            "type": "array"
          },
          "agency": {
            "$ref": "#/components/schemas/Agency"
          },
          "arrival": {
            "$ref": "#/components/schemas/TransitDeparture"
          },
          "attributions": {
            "description": "List of required attributions to display.",
            "items": {
              "$ref": "#/components/schemas/Attribution"
            },
            "type": "array"
          },
          "booking": {
            "$ref": "#/components/schemas/WebLink",
            "deprecated": true,
            "description": "**NOTE:** Attribute booking is deprecated. Please, use bookingLinks instead of it.\n"
          },
          "bookingLinks": {
            "description": "Links to external ticket booking services",
            "items": {
              "$ref": "#/components/schemas/WebLinkWithDeviceType"
            },
            "type": "array"
          },
          "departure": {
            "$ref": "#/components/schemas/TransitDeparture"
          },
          "fares": {
            "description": "List of tickets to pay for this section of the route",
            "items": {
              "$ref": "#/components/schemas/Fare"
            },
            "type": "array"
          },
          "id": {
            "description": "Unique identifier of the section",
            "type": "string"
          },
          "incidents": {
            "description": "A list of all incidents that apply to the section.",
            "items": {
              "$ref": "#/components/schemas/TransitIncident"
            },
            "type": "array"
          },
          "intermediateStops": {
            "description": "Intermediate stops between departure and destination of the transit line. It can be missing if this information is not available or not requested.\n",
            "items": {
              "$ref": "#/components/schemas/TransitStop"
            },
            "type": "array"
          },
          "language": {
            "description": "Language of the localized strings in the section, if any, in BCP47 format.",
            "type": "string"
          },
          "notices": {
            "description": "Contains a list of issues related to this section of the route.\n",
            "items": {
              "$ref": "#/components/schemas/TransitNotice"
            },
            "type": "array"
          },
          "passthrough": {
            "description": "List of via waypoints this section is passing through.\n\nEach via waypoint of the request that is a `passThrough=true` waypoint, appears as a\n`Passthrough` in the response. It appears in the section that starts with the closest\nnon-passthrough via specified before it or origin.\n\nThe passthrough vias appear in this list in the order they are traversed. They are\ntraversed in the order they are specified in the request.\n",
            "items": {
              "$ref": "#/components/schemas/Passthrough"
            },
            "type": "array"
          },
          "polyline": {
            "$ref": "#/components/schemas/Polyline"
          },
          "postActions": {
            "description": "Actions that must be done after `arrival`.",
            "items": {
              "$ref": "#/components/schemas/TransitPostAction"
            },
            "type": "array"
          },
          "preActions": {
            "description": "Actions that must be done prior to `departure`.",
            "items": {
              "$ref": "#/components/schemas/TransitPreAction"
            },
            "type": "array"
          },
          "spans": {
            "description": "Span attached to a `Section` describing transit content.\n",
            "items": {
              "$ref": "#/components/schemas/TransitSpan"
            },
            "type": "array"
          },
          "summary": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BaseSummary"
              }
            ],
            "description": "Total value of key attributes (e.g., duration, length) summed up for the entire section, including `preActions`, `postActions`,\nand the travel portion of the section.\n"
          },
          "transport": {
            "$ref": "#/components/schemas/TransitTransport"
          },
          "travelSummary": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BaseSummary"
              }
            ],
            "description": "Total value of key attributes (e.g., duration, length) summed up for just the travel portion of the section,\nbetween `departure` and `arrival`. `preActions` and `postActions` are excluded.\n"
          },
          "turnByTurnActions": {
            "description": "Actions for turn by turn guidance during the travel portion of the section, i.e., between `departure` and `arrival`.",
            "items": {
              "$ref": "#/components/schemas/OffsetAction"
            },
            "type": "array"
          },
          "type": {
            "description": "Section type used by the client to identify what extension to the BaseSection are available.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "type",
          "departure",
          "arrival"
        ]
      },
      "TransitSpan": {
        "description": "Contains information attached to a contiguous part of a `Section`. The information may be\nattached along different dimensions of a section which are geometry (spatial), distance or\ntime.\n\nA section, if it uses spans, has an optional attribute `spans` which is an array of\nextended `Span` types.\n\nThe attributes of a span which should be returned in the response are\nconfigured by a request parameter.\n\nUse this type as a base for any span extension for sections that provide spans.\n",
        "properties": {
          "countryCode": {
            "$ref": "#/components/schemas/CountryCode"
          },
          "duration": {
            "$ref": "#/components/schemas/Duration",
            "description": "Duration of the span."
          },
          "length": {
            "$ref": "#/components/schemas/Distance",
            "description": "Length of the span.\n"
          },
          "names": {
            "description": "Designated name for the span (e.g. a street name or a transport name)",
            "items": {
              "$ref": "#/components/schemas/LocalizedString"
            },
            "type": "array"
          },
          "offset": {
            "description": "Offset of a coordinate in the section's polyline.\n",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "refReplacements": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Dictionary of placeholders to replacement strings for the compact representation of map entity references.\n\nThis attribute will not appear for HERE Public Transit v8 and HERE Intermodal Routing v8 requests\n",
            "type": "object"
          },
          "segmentId": {
            "deprecated": true,
            "description": "**NOTE:** Attribute segmentId is deprecated. Use segmentRef instead.\n\nThe directed topology segment id including prefix (e.g '+here:cm:segment:').\n\nThe id consists of two parts.\n* The direction ('+' or '-')\n* followed by the topology segment id (a unique identifier within the HERE platform catalogs).\n\nThe direction specifies whether the route is using the segment in its canonical direction ('+' aka traveling along the geometry's direction), or against it ('-' aka traveling against the geometry's direction).\n\nThis attribute will not appear for HERE Public Transit v8 and HERE Intermodal Routing v8 requests\n",
            "type": "string"
          },
          "segmentRef": {
            "description": "A reference to the HMC topology segment used in this span.\n\nThe standard representation of a segment reference has the following structure:\n{catalogHrn}:{catalogVersion}:({layerId})?:{tileId}:{segmentId}(#{direction}({startOffset}..{endOffset})?)?\n\nThe individual parts are:\n* catalogHrn: The HERE Resource Name that identifies the source catalog of the segment, example: hrn:here:data::olp-here:rib-2\n* catalogVersion: The catalog version\n* layerId (optional): The layer inside the catalog where the segment can be found, example: topology-geometry\n* tileId: The HERE tile key of the partition/tile where the segment is located in the given version of the catalog. This can be on a lower level than the actual segment is stored at (for example, the provided tile ID can be on level 14, despite topology-geometry partitions being tiled at level 12). The level of a HERE tile key is indicated by the position of the highest set bit in binary representation. Since the HERE tile key represents a morton code of the x and y portion of the Tile ID, the level 12 tile ID can be retrieved from the level 14 tile ID by removing the 4 least significant bits (or 2 bits per level) or 1 hexadecimal digit. For example, the level 14 tile 377894441 is included in the level 12 tile 23618402 (377894441<sub>10</sub> = 16863629<sub>16</sub> &rightarrow; 1686362<sub>16</sub> = 23618402<sub>10</sub>)\n* segmentId: The identifier of the referenced topology segment inside the catalog, example: here:cm:segment:84905195\n* direction (optional): Either '*' for undirected or bidirectional, '+' for positive direction, '-' for negative direction, or '?' for unknown direction (not used by the routing service)\n* startOffset/endOffset (optional): The start- and end offset are non-negative numbers between 0 and 1, representing the start and end of the referenced range using a proportion of the length of the segment. 0 represents the start and 1 the end of the segment, relative to the indicated direction (or positive direction in case of undirected segments). Example: 0.7..1\n\nThis attribute will not appear for HERE Public Transit v8 and HERE Intermodal Routing v8 requests\n\nExample of a segment reference in standard representation:\nhrn:here:data::olp-here:rib-2:1363::377894441:here:cm:segment:84905195#+0.7..1\n\nThe segment references can also be provided in a compact representation, to reduce the response size. In the compact representation, some parts are replaced by placeholders, which can be resolved using the refReplacements dictionary in the parent section.\nThe placeholder format is ```\\$\\d+``` and needs to be surrounded by colons or string start/end. It can be captured with the following regular expression: ```(^|:)\\$\\d+(:|$)/``` .\n\nExample of the segment reference previously mentioned in compact representation:\n$0:377894441:$1:84905195#+0.7..1\nWith the corresponding refReplacements:\n\"refReplacements\": {\n  \"0\": \"hrn:here:data::olp-here:rib-2:1363:\",\n  \"1\": \"here:cm:segment\"\n}\n",
            "type": "string"
          },
          "stateCode": {
            "$ref": "#/components/schemas/StateCode"
          }
        }
      },
      "TransitStop": {
        "description": "A transit stop of the route",
        "properties": {
          "attributes": {
            "description": "**NOTE:** As it is possible that new attributes are supported in the future, unknown attributes should be ignored.\n",
            "items": {
              "$ref": "#/components/schemas/TransitStopAttributes"
            },
            "type": "array"
          },
          "departure": {
            "$ref": "#/components/schemas/TransitDeparture"
          },
          "duration": {
            "default": 0,
            "description": "Stop duration. If not set the vehicle departs as soon as people are on board.",
            "type": "integer"
          }
        },
        "required": [
          "departure"
        ]
      },
      "TransitStopAttributes": {
        "description": "Extensible enum: `noEntry` `noExit` `...`  \nAttributes of a stop.\n\n* `noEntry`: The transport cannot be entered at the stop.\n* `noExit`: The transport cannot be exited at the stop.\n",
        "type": "string",
        "x-extensible-enum": [
          "noEntry",
          "noExit"
        ]
      },
      "TransitTransport": {
        "description": "Transit transport information.",
        "properties": {
          "category": {
            "description": "Human readable transport category (such as Bus, Gondola, Tram, Train, ...)",
            "type": "string"
          },
          "color": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Color"
              }
            ],
            "description": "Color of the transport polyline and background for the transport name."
          },
          "headsign": {
            "description": "Transit line headsign",
            "type": "string"
          },
          "longName": {
            "description": "Long name of a transit line.",
            "example": "Pankow - Ruhleben",
            "type": "string"
          },
          "mode": {
            "$ref": "#/components/schemas/TransitModeOutput"
          },
          "name": {
            "description": "Transit line name",
            "example": "U2",
            "type": "string"
          },
          "shortName": {
            "description": "Short name of a transit line.",
            "example": "U2",
            "type": "string"
          },
          "textColor": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Color"
              }
            ],
            "description": "Color of the transport name."
          }
        },
        "required": [
          "mode"
        ]
      },
      "Truck": {
        "deprecated": true,
        "description": "Vehicle specific parameters",
        "properties": {
          "axleCount": {
            "description": "Value specifying the total number of axles the vehicle has i.e., axles on the base vehicle and any attached trailers.\n\n**Limitations:** only valid for `transportMode=truck`.\n",
            "format": "int32",
            "maximum": 255,
            "minimum": 2,
            "type": "integer"
          },
          "category": {
            "default": "undefined",
            "description": "Specifies the category of the vehicle. The supported values are:\n\n* `undefined`: The vehicle category is undefined and no special considerations are taken into\n  account. Vehicle routing will proceed as normal.\n* `lightTruck`: The vehicle is a truck light enough to be classified more as a car than as a truck.\n  I.e., this exempts it from many legal restrictions for normal trucks. Restrictions related\n  to the physical dimensions of the truck, or its cargo, however, still apply.\n\n  Please refer to the developer guide for further details on Truck Categories.\n\n  **Limitations:** only valid for `transportMode=truck`.\n",
            "enum": [
              "undefined",
              "lightTruck"
            ],
            "type": "string"
          },
          "grossWeight": {
            "description": "Vehicle weight including trailers and shipped goods, in kilograms.\n\n**Limitations:** only valid for `transportMode=truck`.\n",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "height": {
            "description": "Vehicle height, in centimeters.\n\n**Limitations:** only valid for `transportMode=truck`.\n",
            "format": "int32",
            "maximum": 5000,
            "minimum": 0,
            "type": "integer"
          },
          "hovOccupancy": {
            "default": 1,
            "description": "Number of occupants (defined as occupying a seat with a restraint device) in the vehicle.\nThis value affects the ability of the router to use HOV (High-Occupancy Vehicles) restricted lanes.\n\nLimitations:\n  * currently, any value over 1 is interpreted as being able to use any HOV lane (including, e.g. those restricted to 3+ passengers).\n",
            "minimum": 1,
            "type": "integer"
          },
          "length": {
            "description": "Vehicle length, in centimeters.\n\n**Limitations:** only valid for `transportMode=truck`.\n",
            "format": "int32",
            "maximum": 30000,
            "minimum": 0,
            "type": "integer"
          },
          "licensePlate": {
            "description": "Specifies information about the vehicle's license plate number.\nThis information is used to evaluate whether certain vehicle restrictions in environmental zones apply.\nCurrently, only the last character of the license plate can be provided.\n\nFormat: `lastCharacter:{character}`\n\nExample: `lastCharacter:2`\n",
            "type": "string"
          },
          "shippedHazardousGoods": {
            "description": "Comma-separated list of shipped hazardous goods in the vehicle.\n\nPossible values are:\n\n* `explosive`: Explosive material\n* `gas`: Gas\n* `flammable`: Flammable material\n* `combustible`: Combustible material\n* `organic`: Organic material\n* `poison`: Poison\n* `radioactive`: Radioactive material\n* `corrosive`: Corrosive material\n* `poisonousInhalation`: Materials that are poisonous upon inhalation\n* `harmfulToWater`: Materials that are harmful to water\n* `other`: Other types of hazardous materials\n\n**Limitations:** only valid for `transportMode=truck`.\n",
            "example": "explosive,gas,flammable",
            "type": "string"
          },
          "speedCap": {
            "description": "Specifies the maximum speed, in m/s, which the user wishes not to exceed.\nThis parameter affects route ETA and consumption calculation.\n\nLimitations:\n  * valid for following transport modes: `car`, `truck`, `scooter`, `taxi`, `bus`, and `privateBus`\n\nNotes:\n  * Car and Truck mode updates route ETA.\n  * Scooter mode updates route optimization and ETA.\n",
            "maximum": 70,
            "minimum": 1,
            "type": "number"
          },
          "tiresCount": {
            "description": "Value specifying the total number of tires the vehicle has i.e., tires on the base vehicle and any attached trailers.\n\nNote: This parameter is currently used only for calculation of tolls in regions where it is applicable.\n",
            "format": "int32",
            "maximum": 255,
            "minimum": 1,
            "type": "integer"
          },
          "trailerAxleCount": {
            "description": "Value specifying the total number of axles across all the trailers attached to the vehicle.\nThis number is included in `axleCount`, hence `trailerAxleCount` must be less than `axleCount`.\n\n**Limitations:** only valid for `transportMode=truck`, `trailerCount` > 0 and `axleCount` > 1.\n\nNote: This parameter is currently used only for calculation of tolls in regions where it is applicable.\n",
            "format": "int32",
            "minimum": 1,
            "type": "integer"
          },
          "trailerCount": {
            "default": 0,
            "description": "Number of trailers attached to the vehicle.\n\n**Limitations:** only valid for `transportMode=truck`.\n",
            "format": "int32",
            "maximum": 255,
            "minimum": 0,
            "type": "integer"
          },
          "tunnelCategory": {
            "$ref": "#/components/schemas/TunnelCategory"
          },
          "type": {
            "$ref": "#/components/schemas/TruckTypeWithDefault"
          },
          "weightPerAxle": {
            "description": "Heaviest vehicle weight per axle, in kilograms.\n\nHeaviest weight per axle, regardless of axle type or axle group. It is evaluated against\nall axle weight restrictions, including single axle and tandem axle weight restrictions.\nIt is useful if differences between axle types, like tandem and triple axles, are not\nrelevant. This is the case in many countries, since they don't distinguish between these\ndifferent axle groups on signs and in regulations.\n\nMore fine-grained axle weight input is possible with `weightPerAxleGroup`.\n\n**Note:** `weightPerAxleGroup` and `weightPerAxle` are incompatible.\n**Limitations:** only valid for `transportMode=truck`.\n",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "weightPerAxleGroup": {
            "$ref": "#/components/schemas/WeightPerAxleGroup"
          },
          "width": {
            "description": "Vehicle width, in centimeters.\n\n**Limitations:** only valid for `transportMode=truck`.\n",
            "format": "int32",
            "maximum": 5000,
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "TruckAxleCountRange": {
        "description": "Constrains the restriction to trucks with number of axles within specified range.",
        "properties": {
          "from": {
            "description": "Inclusive minimum of axle count.",
            "format": "int32",
            "minimum": 2,
            "type": "integer"
          },
          "to": {
            "description": "Inclusive maximum of axle count. If not set, maximum axle count is unbounded.",
            "format": "int32",
            "minimum": 2,
            "type": "integer"
          }
        }
      },
      "TruckType": {
        "deprecated": true,
        "description": "Specifies the type of truck\n\n* `straight`: a truck on a single frame with a permanently attached cargo area\n* `tractor`: a towing vehicle that can pull one or more semi-trailers (aka semi-truck)\n",
        "enum": [
          "straight",
          "tractor"
        ],
        "type": "string"
      },
      "TruckTypeWithDefault": {
        "default": "straight",
        "deprecated": true,
        "description": "Specifies the type of truck\n\n* `straight`: a truck on a single frame with a permanently attached cargo area\n* `tractor`: a towing vehicle that can pull one or more semi-trailers (aka semi-truck)\n",
        "enum": [
          "straight",
          "tractor"
        ],
        "type": "string"
      },
      "TunnelCategory": {
        "description": "Specifies the tunnel category used to restrict transport of specific goods.\n\n**Limitations:** only valid for `transportMode=truck`.\n",
        "enum": [
          "B",
          "C",
          "D",
          "E"
        ],
        "type": "string"
      },
      "TurnAction": {
        "description": "An action in which a direction change is made.\n\n* `ramp`: ramp maneuver, such as \"Take the left ramp onto\"\n* `roundaboutPass`: Going straight on a roundabout maneuver\n* `roundaboutEnter`: Arriving at a destination roundabout maneuver\n* `uTurn`: u-turn maneuver, such as \"Make a right U-turn at\"\n* `turn`: turn maneuver, such as \"Make a sharp right turn at\"\n* `keep`: a maneuver following a fork, such as \"Take the middle fork onto\"\n* `enterHighway`: a maneuver to enter a highway, used for turn-by-turn guidance only\n",
        "properties": {
          "action": {
            "description": "The type of the action.\n\n**NOTE:** The list of possible actions may be extended in the future. The client application should handle such a case gracefully.\n",
            "type": "string"
          },
          "currentRoad": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RoadInfo"
              }
            ],
            "description": "Attributes of the current road"
          },
          "direction": {
            "$ref": "#/components/schemas/TurnActionDirection"
          },
          "duration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "Estimated duration of this action (in seconds). Actions last until the next action, or the end of the route in case of the last one."
          },
          "exitSign": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ExitInfo"
              }
            ],
            "description": "Attributes of the road exit"
          },
          "instruction": {
            "description": "Description of the action (e.g. Turn left onto Minna St.).",
            "type": "string"
          },
          "intersectionName": {
            "description": "Name of the intersection where the turn takes place, if available.",
            "items": {
              "$ref": "#/components/schemas/LocalizedString"
            },
            "type": "array"
          },
          "length": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Distance"
              }
            ],
            "description": "Estimated length of this action (in meters). Actions extend until the next action, or the end of the route in case of the last one."
          },
          "nextRoad": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RoadInfo"
              }
            ],
            "description": "Attributes of the next road"
          },
          "offset": {
            "description": "Offset of a coordinate in the section's polyline.",
            "type": "integer"
          },
          "severity": {
            "$ref": "#/components/schemas/TurnActionSeverity"
          }
        },
        "required": [
          "action",
          "duration"
        ]
      },
      "TurnActionDirection": {
        "description": "Direction of the turn. `middle` is only used by the `keep` action.",
        "enum": [
          "middle",
          "right",
          "left"
        ],
        "type": "string"
      },
      "TurnActionSeverity": {
        "description": "Tightness of the turn. Optional in the `turn` action, unused by other actions.\n\n* `light`: indicates making a light turn\n* `quite`: indicates making a regular turn\n* `heavy`: indicates making a heavy turn\n",
        "enum": [
          "light",
          "quite",
          "heavy"
        ],
        "type": "string"
      },
      "UTurnAction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/TurnAction"
          }
        ]
      },
      "Units": {
        "description": "Units of measurement used, for example, in guidance instructions. The default is `metric`.",
        "enum": [
          "metric",
          "imperial"
        ],
        "type": "string"
      },
      "Uri": {
        "description": "An URL address that links to a particular resource.",
        "format": "uri",
        "type": "string"
      },
      "Vehicle": {
        "description": "Vehicle specific parameters",
        "properties": {
          "axleCount": {
            "description": "Value specifying the total number of axles the vehicle has i.e., axles on the base vehicle and any attached trailers.\n\n**Limitations:** only valid for `transportMode=truck`.\n",
            "format": "int32",
            "maximum": 255,
            "minimum": 2,
            "type": "integer"
          },
          "category": {
            "default": "undefined",
            "description": "Specifies the category of the vehicle. The supported values are:\n\n* `undefined`: The vehicle category is undefined and no special considerations are taken into\n  account. Vehicle routing will proceed as normal.\n* `lightTruck`: The vehicle is a truck light enough to be classified more as a car than as a truck.\n  I.e., this exempts it from many legal restrictions for normal trucks. Restrictions related\n  to the physical dimensions of the truck, or its cargo, however, still apply.\n\n  Please refer to the developer guide for further details on Truck Categories.\n\n  **Limitations:** only valid for `transportMode=truck`.\n",
            "enum": [
              "undefined",
              "lightTruck"
            ],
            "type": "string"
          },
          "grossWeight": {
            "description": "Vehicle weight including trailers and shipped goods, in kilograms.\n\n**Limitations:** only valid for `transportMode=truck`.\n",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "height": {
            "description": "Vehicle height, in centimeters.\n\n**Limitations:** only valid for `transportMode=truck`.\n",
            "format": "int32",
            "maximum": 5000,
            "minimum": 0,
            "type": "integer"
          },
          "hovOccupancy": {
            "default": 1,
            "description": "Number of occupants (defined as occupying a seat with a restraint device) in the vehicle.\nThis value affects the ability of the router to use HOV (High-Occupancy Vehicles) restricted lanes.\n\nLimitations:\n  * currently, any value over 1 is interpreted as being able to use any HOV lane (including, e.g. those restricted to 3+ passengers).\n",
            "minimum": 1,
            "type": "integer"
          },
          "length": {
            "description": "Vehicle length, in centimeters.\n\n**Limitations:** only valid for `transportMode=truck`.\n",
            "format": "int32",
            "maximum": 30000,
            "minimum": 0,
            "type": "integer"
          },
          "licensePlate": {
            "description": "Specifies information about the vehicle's license plate number.\nThis information is used to evaluate whether certain vehicle restrictions in environmental zones apply.\nCurrently, only the last character of the license plate can be provided.\n\nFormat: `lastCharacter:{character}`\n\nExample: `lastCharacter:2`\n",
            "type": "string"
          },
          "shippedHazardousGoods": {
            "description": "Comma-separated list of shipped hazardous goods in the vehicle.\n\nPossible values are:\n\n* `explosive`: Explosive material\n* `gas`: Gas\n* `flammable`: Flammable material\n* `combustible`: Combustible material\n* `organic`: Organic material\n* `poison`: Poison\n* `radioactive`: Radioactive material\n* `corrosive`: Corrosive material\n* `poisonousInhalation`: Materials that are poisonous upon inhalation\n* `harmfulToWater`: Materials that are harmful to water\n* `other`: Other types of hazardous materials\n\n**Limitations:** only valid for `transportMode=truck`.\n",
            "example": "explosive,gas,flammable",
            "type": "string"
          },
          "speedCap": {
            "description": "Specifies the maximum speed, in m/s, which the user wishes not to exceed.\nThis parameter affects route ETA and consumption calculation.\n\nLimitations:\n  * valid for following transport modes: `car`, `truck`, `scooter`, `taxi`, `bus`, and `privateBus`\n\nNotes:\n  * Car and Truck mode updates route ETA.\n  * Scooter mode updates route optimization and ETA.\n",
            "maximum": 70,
            "minimum": 1,
            "type": "number"
          },
          "tiresCount": {
            "description": "Value specifying the total number of tires the vehicle has i.e., tires on the base vehicle and any attached trailers.\n\nNote: This parameter is currently used only for calculation of tolls in regions where it is applicable.\n",
            "format": "int32",
            "maximum": 255,
            "minimum": 1,
            "type": "integer"
          },
          "trailerAxleCount": {
            "description": "Value specifying the total number of axles across all the trailers attached to the vehicle.\nThis number is included in `axleCount`, hence `trailerAxleCount` must be less than `axleCount`.\n\n**Limitations:** only valid for `transportMode=truck`, `trailerCount` > 0 and `axleCount` > 1.\n\nNote: This parameter is currently used only for calculation of tolls in regions where it is applicable.\n",
            "format": "int32",
            "minimum": 1,
            "type": "integer"
          },
          "trailerCount": {
            "default": 0,
            "description": "Number of trailers attached to the vehicle.\n\n**Limitations:** only valid for `transportMode=truck`.\n",
            "format": "int32",
            "maximum": 255,
            "minimum": 0,
            "type": "integer"
          },
          "tunnelCategory": {
            "$ref": "#/components/schemas/TunnelCategory"
          },
          "type": {
            "$ref": "#/components/schemas/VehicleType"
          },
          "weightPerAxle": {
            "description": "Heaviest vehicle weight per axle, in kilograms.\n\nHeaviest weight per axle, regardless of axle type or axle group. It is evaluated against\nall axle weight restrictions, including single axle and tandem axle weight restrictions.\nIt is useful if differences between axle types, like tandem and triple axles, are not\nrelevant. This is the case in many countries, since they don't distinguish between these\ndifferent axle groups on signs and in regulations.\n\nMore fine-grained axle weight input is possible with `weightPerAxleGroup`.\n\n**Note:** `weightPerAxleGroup` and `weightPerAxle` are incompatible.\n**Limitations:** only valid for `transportMode=truck`.\n",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "weightPerAxleGroup": {
            "$ref": "#/components/schemas/WeightPerAxleGroup"
          },
          "width": {
            "description": "Vehicle width, in centimeters.\n\n**Limitations:** only valid for `transportMode=truck`.\n",
            "format": "int32",
            "maximum": 5000,
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "VehicleAction": {
        "description": "Action attached to a vehicle section.",
        "discriminator": {
          "mapping": {
            "arrive": "#/components/schemas/ArriveAction",
            "continue": "#/components/schemas/ContinueAction",
            "depart": "#/components/schemas/DepartAction",
            "exit": "#/components/schemas/ExitAction",
            "keep": "#/components/schemas/KeepAction",
            "ramp": "#/components/schemas/RampAction",
            "roundaboutEnter": "#/components/schemas/RoundaboutEnterAction",
            "roundaboutExit": "#/components/schemas/RoundaboutExitAction",
            "roundaboutPass": "#/components/schemas/RoundaboutPassAction",
            "turn": "#/components/schemas/TurnAction",
            "uTurn": "#/components/schemas/UTurnAction"
          },
          "propertyName": "action"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/DepartAction"
          },
          {
            "$ref": "#/components/schemas/ArriveAction"
          },
          {
            "$ref": "#/components/schemas/ContinueAction"
          },
          {
            "$ref": "#/components/schemas/RampAction"
          },
          {
            "$ref": "#/components/schemas/ExitAction"
          },
          {
            "$ref": "#/components/schemas/RoundaboutPassAction"
          },
          {
            "$ref": "#/components/schemas/RoundaboutEnterAction"
          },
          {
            "$ref": "#/components/schemas/RoundaboutExitAction"
          },
          {
            "$ref": "#/components/schemas/UTurnAction"
          },
          {
            "$ref": "#/components/schemas/TurnAction"
          },
          {
            "$ref": "#/components/schemas/KeepAction"
          }
        ]
      },
      "VehicleDeparture": {
        "description": "Describe a departure or arrival location and time.",
        "properties": {
          "charge": {
            "description": "Vehicle battery charge (in kWh).",
            "type": "number"
          },
          "place": {
            "$ref": "#/components/schemas/VehiclePlace"
          },
          "time": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Time"
              }
            ],
            "description": "Expected time of departure of the event. Format is **RFC 3339**, section 5.6 as defined by `date-time`."
          }
        },
        "required": [
          "place"
        ]
      },
      "VehicleMode": {
        "default": "car",
        "description": "Extensible enum: `car` `truck` `scooter` `...`  \nVehicle mode of transport.\n\nSince the supported vehicle modes may be extended in the future, the vehicle mode should be hidden when an unknown mode is encountered.\n",
        "type": "string",
        "x-extensible-enum": [
          "car",
          "truck",
          "scooter"
        ]
      },
      "VehicleNotice": {
        "description": "A notice contains important notifications.",
        "example": {
          "$ref": "#/components/examples/noticeWithRestrictionsExample"
        },
        "properties": {
          "code": {
            "description": "Extensible enum: `violatedAvoidControlledAccessHighway` `violatedAvoidTollRoad` `violatedAvoidTunnel` `violatedAvoidDirtRoad` `violatedBlockedRoad` `violatedStartDirection` `violatedCarpool` `violatedTurnRestriction` `violatedVehicleRestriction` `violatedZoneRestriction` `violatedAvoidDifficultTurns` `violatedAvoidUTurns` `violatedEmergencyGate` `violatedAvoidSeasonalClosure` `violatedAvoidTollTransponder` `seasonalClosure` `tollTransponder` `mlDurationUnavailable` `simplePolyline` `tollsDataUnavailable` `chargingStopNotNeeded` `...`  \nCurrently known codes (non-exhaustive: this list could be extended for new situations):\n\n| Code      | Description  | Severity |\n| --------- | ------- | ----            |\n| violatedAvoidControlledAccessHighway | Route did not manage to avoid user preference | critical |\n| violatedAvoidTollRoad | Route did not manage to avoid user preference | critical |\n| violatedAvoidTunnel | Route did not manage to avoid user preference | critical |\n| violatedAvoidDirtRoad | Route did not manage to avoid user preference | critical |\n| violatedBlockedRoad | Route uses roads blocked by traffic events | critical |\n| violatedStartDirection | Start direction of the route is not as requested | critical |\n| violatedCarpool | Route did not manage to avoid user preference | critical |\n| violatedTurnRestriction | Route uses a time-restricted turn | critical |\n| violatedVehicleRestriction | Route uses a road which is forbidden for the given vehicle profile | critical |\n| violatedZoneRestriction | Route uses a road which is part of restricted routing zones | critical |\n| violatedAvoidDifficultTurns | Route did not manage to avoid user preference | critical |\n| violatedAvoidUTurns | Route did not manage to avoid user preference | critical |\n| violatedEmergencyGate | Route goes through an emergency gate | critical |\n| violatedAvoidSeasonalClosure | Route did not manage to avoid seasonal closure | critical |\n| violatedAvoidTollTransponder | Route did not manage to avoid toll booth that requires transponder | critical |\n| seasonalClosure | Route goes through seasonal closure | info |\n| tollTransponder | Route goes through toll booth that requires transponder | info |\n| mlDurationUnavailable | Machine learning duration was requested but is not available for this section | info |\n| simplePolyline | An accurate polyline is not available for this section. The returned polyline has been generated from departure and arrival places. | info |\n| tollsDataUnavailable | Tolls data was requested but could not be calculated for this section | info |\n| chargingStopNotNeeded | A charging stop was planned at the destination of this section, but it is no longer needed (getRoutesByHandle requests only) | info |\n",
            "example": "violatedAvoidTollRoad",
            "type": "string",
            "x-extensible-enum": [
              "violatedAvoidControlledAccessHighway",
              "violatedAvoidTollRoad",
              "violatedAvoidTunnel",
              "violatedAvoidDirtRoad",
              "violatedBlockedRoad",
              "violatedStartDirection",
              "violatedCarpool",
              "violatedTurnRestriction",
              "violatedVehicleRestriction",
              "violatedZoneRestriction",
              "violatedAvoidDifficultTurns",
              "violatedAvoidUTurns",
              "violatedEmergencyGate",
              "violatedAvoidSeasonalClosure",
              "violatedAvoidTollTransponder",
              "seasonalClosure",
              "tollTransponder",
              "mlDurationUnavailable",
              "simplePolyline",
              "tollsDataUnavailable",
              "chargingStopNotNeeded"
            ]
          },
          "details": {
            "description": "Additional details about the notice",
            "items": {
              "$ref": "#/components/schemas/VehicleNoticeDetail"
            },
            "type": "array"
          },
          "severity": {
            "$ref": "#/components/schemas/NoticeSeverity"
          },
          "title": {
            "description": "Human-readable notice description.",
            "example": "Violated avoid toll road",
            "type": "string"
          }
        },
        "required": [
          "code"
        ]
      },
      "VehicleNoticeDetail": {
        "description": "Details attached to notices in vehicle section.",
        "discriminator": {
          "mapping": {
            "restriction": "#/components/schemas/VehicleRestriction",
            "violatedTransportMode": "#/components/schemas/ViolatedTransportMode"
          },
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/VehicleRestriction"
          },
          {
            "$ref": "#/components/schemas/ViolatedTransportMode"
          }
        ]
      },
      "VehiclePlace": {
        "description": "Place used in vehicle routing.",
        "discriminator": {
          "mapping": {
            "accessPoint": "#/components/schemas/AccessPointPlace",
            "chargingStation": "#/components/schemas/ChargingStationPlace",
            "dockingStation": "#/components/schemas/DockingStationPlace",
            "parkingLot": "#/components/schemas/ParkingLotPlace",
            "place": "#/components/schemas/Place",
            "station": "#/components/schemas/StationPlace"
          },
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/Place"
          },
          {
            "$ref": "#/components/schemas/StationPlace"
          },
          {
            "$ref": "#/components/schemas/AccessPointPlace"
          },
          {
            "$ref": "#/components/schemas/ParkingLotPlace"
          },
          {
            "$ref": "#/components/schemas/ChargingStationPlace"
          },
          {
            "$ref": "#/components/schemas/DockingStationPlace"
          }
        ]
      },
      "VehiclePostAction": {
        "description": "Action attached to a vehicle section that must be done after `arrival`.",
        "discriminator": {
          "mapping": {
            "charging": "#/components/schemas/ChargingAction",
            "chargingSetup": "#/components/schemas/ChargingSetupAction",
            "wait": "#/components/schemas/OffsetAction"
          },
          "propertyName": "action"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/ChargingSetupAction"
          },
          {
            "$ref": "#/components/schemas/ChargingAction"
          },
          {
            "$ref": "#/components/schemas/OffsetAction"
          }
        ]
      },
      "VehicleRestriction": {
        "description": "Contains details about violated restrictions.\n\nCertain properties represent conditions to be evaluated, e.g., according to vehicle properties.\nThe restriction is violated if and only if all of the conditions present are met.\n",
        "example": {
          "$ref": "#/components/examples/restrictionExample"
        },
        "properties": {
          "axleCount": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TruckAxleCountRange"
              }
            ],
            "description": "Constrains the restriction to trucks with number of axles within specified range.\n\nThis condition is met when the vehicle's `axleCount` is within the range specified.\n"
          },
          "cause": {
            "description": "Cause of the notice",
            "type": "string"
          },
          "forbiddenHazardousGoods": {
            "description": "Hazardous goods restrictions applied during the trip.\n\nThis condition is met when the vehicle's shippedHazardousGoods\ncontains any of the items in this array.\n",
            "items": {
              "$ref": "#/components/schemas/HazardousGoodsRestriction"
            },
            "type": "array"
          },
          "maxGrossWeight": {
            "description": "Contains max permitted gross weight, in kilograms.\n\nThis condition is met when the vehicle's `grossWeight` exceeds this value.\n",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "maxHeight": {
            "description": "Contains max permitted height, in centimeters.\n\nThis condition is met when the vehicle's `height` exceeds this value.\n",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "maxLength": {
            "description": "Contains max permitted length, in centimeters.\n\nThis condition is met when the vehicle's `length` exceeds this value.\n",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "maxWeightPerAxle": {
            "description": "Contains max permitted weight per axle, in kilograms.\n\nThis condition is met when the vehicle's `weightPerAxle` exceeds this value.\n",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "maxWidth": {
            "description": "Contains max permitted width, in centimeters.\n\nThis condition is met when the vehicle's `width` exceeds this value.\n",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "timeDependent": {
            "description": "Indicates that restriction depends on time.\n",
            "type": "boolean"
          },
          "title": {
            "description": "Detail title",
            "type": "string"
          },
          "trailerCount": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TrailerCountRange"
              }
            ],
            "description": "Constrains the restriction to trucks with number of axles within specified range.\n\nThis condition is met when the vehicle's `trailerCount` is within the range specified.\n"
          },
          "truckType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TruckType"
              }
            ],
            "deprecated": true,
            "description": "Constrains the restriction to a specific type of vehicle.\n\nThis condition is met if the `vehicle[type]` request parameter matches this value.\n"
          },
          "tunnelCategory": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TunnelCategory"
              }
            ],
            "description": "Specifies the tunnel category used to restrict transport of specific goods.\n\nThis condition is met when the value exceeds the tunnel category specified\nby the vehicle's `tunnelCategory`\n"
          },
          "type": {
            "description": "Detail type. Each type of detail might contain extra attributes.\n\n**NOTE:** The list of possible detail types may be extended in the future.\nThe client application is expected to handle such a case gracefully.\n",
            "type": "string"
          },
          "vehicleType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VehicleType"
              }
            ],
            "description": "Constrains the restriction to a specific type of vehicle.\n\nThis condition is met if the `vehicle[type]` request parameter matches this value.\n"
          }
        },
        "required": [
          "type"
        ]
      },
      "VehicleSection": {
        "description": "Represent a section of a route",
        "properties": {
          "actions": {
            "description": "Actions to be performed at or during a specific portion of a section.\n\nAction offsets are the coordinate index in the polyline.\n\n*NOTE:* currentRoad and nextRoad are not populated for actions.\n",
            "items": {
              "$ref": "#/components/schemas/VehicleAction"
            },
            "type": "array"
          },
          "arrival": {
            "$ref": "#/components/schemas/VehicleDeparture"
          },
          "departure": {
            "$ref": "#/components/schemas/VehicleDeparture"
          },
          "id": {
            "description": "Unique identifier of the section",
            "type": "string"
          },
          "incidents": {
            "description": "A list of all incidents that apply to the section.",
            "items": {
              "$ref": "#/components/schemas/TrafficIncident"
            },
            "type": "array"
          },
          "language": {
            "description": "Language of the localized strings in the section, if any, in BCP47 format.",
            "type": "string"
          },
          "notices": {
            "description": "Contains a list of issues related to this section of the route.\n\nNotices must be carefully evaluated and the route section should be discarded\nif appropriate.\nIn particular, the user should be aware that new notice codes may be added at any time. If an unrecognized\nnotice code appears with a `critical` severity level, the route section must be discarded.\nPlease refer to the `code` attribute for possible values.\n",
            "items": {
              "$ref": "#/components/schemas/VehicleNotice"
            },
            "type": "array"
          },
          "passthrough": {
            "description": "List of via waypoints this section is passing through.\n\nEach via waypoint of the request that is a `passThrough=true` waypoint, appears as a\n`Passthrough` in the response. It appears in the section that starts with the closest\nnon-passthrough via specified before it or origin.\n\nThe passthrough vias appear in this list in the order they are traversed. They are\ntraversed in the order they are specified in the request.\n",
            "items": {
              "$ref": "#/components/schemas/Passthrough"
            },
            "type": "array"
          },
          "polyline": {
            "$ref": "#/components/schemas/Polyline"
          },
          "postActions": {
            "description": "Actions that must be done after `arrival`.",
            "items": {
              "$ref": "#/components/schemas/VehiclePostAction"
            },
            "type": "array"
          },
          "preActions": {
            "description": "Actions that must be done prior to `departure`.",
            "items": {
              "$ref": "#/components/schemas/BaseAction"
            },
            "type": "array"
          },
          "refReplacements": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Dictionary of placeholders to replacement strings for the compact representation of map entity references.\n",
            "type": "object"
          },
          "routingZones": {
            "description": "A list of routing zones that are applicable to the section.\n\nElements of this list will be referenced by indices within the `span` attribute of the section.\n",
            "items": {
              "$ref": "#/components/schemas/RoutingZone"
            },
            "type": "array"
          },
          "spans": {
            "description": "Spans attached to a `Section` describing vehicle content.\n",
            "items": {
              "$ref": "#/components/schemas/VehicleSpan"
            },
            "type": "array"
          },
          "summary": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VehicleSummary"
              }
            ],
            "description": "Total value of key attributes (e.g., duration, length, consumption) summed up for the entire section, including `preActions`, `postActions`,\nand the travel portion of the section.\n"
          },
          "tollSystems": {
            "description": "An array of toll authorities that collect payments for the use of (part of) this section of the route.\n",
            "items": {
              "$ref": "#/components/schemas/TollSystem"
            },
            "type": "array"
          },
          "tolls": {
            "description": "Detail of tolls to be paid for traversing this section.\n",
            "items": {
              "$ref": "#/components/schemas/TollCost"
            },
            "type": "array"
          },
          "transport": {
            "$ref": "#/components/schemas/VehicleTransport"
          },
          "travelSummary": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VehicleTravelSummary"
              }
            ],
            "description": "Total value of key attributes (e.g., duration, length, consumption) summed up for just the travel portion of the section,\nbetween `departure` and `arrival`. `preActions` and `postActions` are excluded.\n"
          },
          "truckRoadTypes": {
            "description": "A list of truck road types that are applicable to the section.\n\nElements of this list will be referenced by indices within the `span` attribute of the section.\n\nA truck road type is an identifier associated with roads that have additional regulations applied by local administration for\ntraversal by heavy vehicles like trucks. For example, the BK Bearing Class regulations in Sweden, and ET categories in Mexico.\nThe identifiers of supported truck road types are specified at HERE Map Content\n[TruckRoadType](https://developer.here.com/documentation/here-map-content/dev_guide/topics_schema/truckroadtypeattribute.truckroadtype.html).\n\nThese names should be provided when avoiding a certain truck road type.\n",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "turnByTurnActions": {
            "description": "Actions for turn by turn guidance.\n\nAction offsets are the coordinate index in the polyline.\n",
            "items": {
              "$ref": "#/components/schemas/VehicleAction"
            },
            "type": "array"
          },
          "type": {
            "description": "Section type used by the client to identify what extension to the BaseSection are available.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "type",
          "departure",
          "arrival",
          "transport"
        ]
      },
      "VehicleSpan": {
        "description": "Span attached to a `Section` describing vehicle content.\n",
        "properties": {
          "baseDuration": {
            "$ref": "#/components/schemas/Duration",
            "description": "Duration of this span (in seconds) ignoring time-aware information.\n\nIn particular, dynamic traffic information is not taken into account. Only average\nfree-flow speeds based on historical traffic are used to calculate this duration.\n\nThe `baseDuration` can also be understood as the best possible duration.\n"
          },
          "carAttributes": {
            "description": "Car specific `AccessAttributes`.\n\n`AccessAttributes` is applied to a span of a route section and describes access flags of a street.\n* `open`: This part of the route is open to cars.\n* `noThrough`: This part of the route can only be traversed if origin, destination or any via waypoint is located there.\n* `tollRoad`: This part of the route is restricted with a fee (or toll).\n\nAs it is possible that new access attributes are supported in the future, unknown access attributes should be ignored.\n",
            "items": {
              "$ref": "#/components/schemas/AccessAttributes"
            },
            "type": "array"
          },
          "consumption": {
            "$ref": "#/components/schemas/Energy",
            "description": "Estimated net energy consumption along this span (in kWh)."
          },
          "countryCode": {
            "$ref": "#/components/schemas/CountryCode"
          },
          "duration": {
            "$ref": "#/components/schemas/Duration",
            "description": "Duration of the span."
          },
          "dynamicSpeedInfo": {
            "$ref": "#/components/schemas/DynamicSpeedInfo"
          },
          "functionalClass": {
            "$ref": "#/components/schemas/FunctionalClass"
          },
          "incidents": {
            "description": "A list of indices into the incident array of the parent section.\nReferences all incidents that apply to the span.\nThis requires `incidents` to be specified as part of the `return` parameter.\n",
            "items": {
              "type": "integer"
            },
            "type": "array"
          },
          "length": {
            "$ref": "#/components/schemas/Distance",
            "description": "Length of the span.\n"
          },
          "maxSpeed": {
            "$ref": "#/components/schemas/MaxSpeed"
          },
          "names": {
            "description": "Designated name for the span (e.g. a street name or a transport name)",
            "items": {
              "$ref": "#/components/schemas/LocalizedString"
            },
            "type": "array"
          },
          "notices": {
            "description": "A list of indices into the notices array of the parent section.\nReferences all notices that apply to the span.\n",
            "items": {
              "type": "integer"
            },
            "type": "array"
          },
          "offset": {
            "description": "Offset of a coordinate in the section's polyline.\n",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "routeNumbers": {
            "description": "Designated route name or number of the span (e.g. 'M25')",
            "items": {
              "$ref": "#/components/schemas/LocalizedString"
            },
            "type": "array"
          },
          "routingZones": {
            "description": "A list of indices into the routing zone array of the parent section.\nReferences all applicable routing zones to the span.\n",
            "items": {
              "type": "integer"
            },
            "type": "array"
          },
          "scooterAttributes": {
            "description": "Scooter specific `AccessAttributes`.\n\n`AccessAttributes` is applied to a span of a route section and describes access flags of a street.\n* `open`: This part of the route is open to scooters.\n\nAs it is possible that new access attributes are supported in the future, unknown access attributes should be ignored.\n",
            "items": {
              "$ref": "#/components/schemas/AccessAttributes"
            },
            "type": "array"
          },
          "segmentId": {
            "deprecated": true,
            "description": "\n**NOTE:** Attribute segmentId is deprecated. Use segmentRef instead.\n\nThe directed topology segment id including prefix (e.g '+here:cm:segment:').\n\nThe id consists of two parts.\n* The direction ('+' or '-')\n* followed by the topology segment id (a unique identifier within the HERE platform catalogs).\n\nThe direction specifies whether the route is using the segment in its canonical direction ('+' aka traveling along the geometry's direction), or against it ('-' aka traveling against the geometry's direction).\n",
            "type": "string"
          },
          "segmentRef": {
            "description": "A reference to the HMC topology segment used in this span.\n\nThe standard representation of a segment reference has the following structure:\n{catalogHrn}:{catalogVersion}:({layerId})?:{tileId}:{segmentId}(#{direction}({startOffset}..{endOffset})?)?\n\nThe individual parts are:\n* catalogHrn: The HERE Resource Name that identifies the source catalog of the segment, example: hrn:here:data::olp-here:rib-2\n* catalogVersion: The catalog version\n* layerId (optional): The layer inside the catalog where the segment can be found, example: topology-geometry\n* tileId: The HERE tile key of the partition/tile where the segment is located in the given version of the catalog. This can be on a lower level than the actual segment is stored at (for example, the provided tile ID can be on level 14, despite topology-geometry partitions being tiled at level 12). The level of a HERE tile key is indicated by the position of the highest set bit in binary representation. Since the HERE tile key represents a morton code of the x and y portion of the Tile ID, the level 12 tile ID can be retrieved from the level 14 tile ID by removing the 4 least significant bits (or 2 bits per level) or 1 hexadecimal digit. For example, the level 14 tile 377894441 is included in the level 12 tile 23618402 (377894441<sub>10</sub> = 16863629<sub>16</sub> &rightarrow; 1686362<sub>16</sub> = 23618402<sub>10</sub>)\n* segmentId: The identifier of the referenced topology segment inside the catalog, example: here:cm:segment:84905195\n* direction (optional): Either '*' for undirected or bidirectional, '+' for positive direction, '-' for negative direction, or '?' for unknown direction (not used by the routing service)\n* startOffset/endOffset (optional): The start- and end offset are non-negative numbers between 0 and 1, representing the start and end of the referenced range using a proportion of the length of the segment. 0 represents the start and 1 the end of the segment, relative to the indicated direction (or positive direction in case of undirected segments). Example: 0.7..1\n\nExample of a segment reference in standard representation:\nhrn:here:data::olp-here:rib-2:1363::377894441:here:cm:segment:84905195#+0.7..1\n\nThe segment references can also be provided in a compact representation, to reduce the response size. In the compact representation, some parts are replaced by placeholders, which can be resolved using the refReplacements dictionary in the parent section.\nThe placeholder format is ```\\$\\d+``` and needs to be surrounded by colons or string start/end. It can be captured with the following regular expression: ```(^|:)\\$\\d+(:|$)/``` .\n\nExample of the segment reference previously mentioned in compact representation:\n$0:377894441:$1:84905195#+0.7..1\nWith the corresponding refReplacements:\n\"refReplacements\": {\n  \"0\": \"hrn:here:data::olp-here:rib-2:1363:\",\n  \"1\": \"here:cm:segment\"\n}\n",
            "type": "string"
          },
          "speedLimit": {
            "$ref": "#/components/schemas/Speed",
            "description": "**NOTE:** Attribute speedLimit is deprecated. Use maxSpeed instead.\n"
          },
          "stateCode": {
            "$ref": "#/components/schemas/StateCode"
          },
          "streetAttributes": {
            "description": "`StreetAttributes` is applied to a span of a route section and describes attribute flags of a street.\n* `rightDrivingSide`: Vehicles have to drive on the right-hand side of the road.\n* `dirtRoad`: This part of the route has an un-paved surface.\n* `tunnel`: This part of the route is a tunnel.\n* `bridge`: This part of the route is a bridge.\n* `ramp`: This part of the route is a ramp (usually connecting to/from/between highways).\n* `motorway`: This part of the route is a controlled access road (usually highways with motorway sign).\n* `roundabout`: This part of the route is a roundabout.\n* `underConstruction`: This part of the route is under construction.\n* `dividedRoad`: This part of the route uses a road with a physical or legal divider in the middle.\n* `privateRoad`: This part of the route uses a privately owned road.\n* `controlledAccessHighway`: This part of the route is a either controlled access or limited access road or both.\n\nAs it is possible that new street attributes are supported in the future, unknown street attributes should be ignored.\n",
            "items": {
              "$ref": "#/components/schemas/StreetAttributes"
            },
            "type": "array"
          },
          "tollSystems": {
            "description": "Specifies the toll systems of a toll (if any) applicable for this specific span.\nSince tolls are not static information, the tolls may or may not be applicable to the same span in different requests,\ndepending on factors like transport mode, time of day, etc.\n\nThe contents of the array are reference indexes into the `tollSystems` array in the enclosing section.\n",
            "items": {
              "type": "integer"
            },
            "type": "array"
          },
          "truckAttributes": {
            "description": "Truck specific `AccessAttributes`.\n\n`AccessAttributes` is applied to a span of a route section and describes access flags of a street.\n* `open`: This part of the route is open to trucks.\n* `noThrough`: This part of the route can only be traversed if origin, destination or any via waypoint is located there.\n* `tollRoad`: This part of the route is restricted with a fee (or toll).\n\nAs it is possible that new access attributes are supported in the future, unknown access attributes should be ignored.\n",
            "items": {
              "$ref": "#/components/schemas/AccessAttributes"
            },
            "type": "array"
          },
          "truckRoadTypes": {
            "description": "A list of indices into the truck road types array of the parent section. References all applicable truck road types to the span.",
            "items": {
              "type": "integer"
            },
            "type": "array"
          },
          "typicalDuration": {
            "$ref": "#/components/schemas/Duration",
            "description": "Duration of this span (in seconds) under typical traffic conditions.\n\nIn particular, dynamic traffic information is not taken into account. Instead,\nspeeds that are typical for the given time of day/day of week based on historical\ntraffic are used to calculate this duration.\n"
          },
          "walkAttributes": {
            "description": "Accessibility and walk-related attribute flags.\n\n* `stairs`: This part of the route is a staircase.\n* `park`: This part of the route is in a park.\n* `indoor`: This part of the route is inside a venue.\n* `open`: This part of the route is open to walking.\n* `noThrough`: This part of the route can only be traversed if origin, destination or any via waypoint is located there.\n* `tollRoad`: Access to this part of the route is restricted with a fee (or toll).\n\nAs it is possible that new attributes are supported in the future, unknown attributes should be ignored.\n",
            "items": {
              "$ref": "#/components/schemas/WalkAttributes"
            },
            "type": "array"
          }
        }
      },
      "VehicleSummary": {
        "description": "Total value of key attributes for a route section.",
        "properties": {
          "baseDuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "Duration (in seconds) ignoring time-aware information.\n\nIn particular, dynamic traffic information is not taken into account. Only average\nfree-flow speeds based on historical traffic are used to calculate this duration.\n\nThe `baseDuration` can also be understood as the best possible duration.\n"
          },
          "consumption": {
            "$ref": "#/components/schemas/Energy",
            "description": "Estimated net energy consumption (in kWh) including charge at charging station if applicable."
          },
          "duration": {
            "$ref": "#/components/schemas/Duration"
          },
          "length": {
            "$ref": "#/components/schemas/Distance"
          },
          "tolls": {
            "$ref": "#/components/schemas/TollSummary",
            "description": "Summary of tolls to be paid for this section of the route (if any), grouped as requested in the `tolls` parameter.\nThis element only appears in the response if at least one grouping criteria was requested.\n"
          },
          "typicalDuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "Duration (in seconds) under typical traffic conditions.\n\nIn particular, dynamic traffic information is not taken into account. Instead,\nspeeds that are typical for the given time of day/day of week based on historical\ntraffic are used to calculate this duration.\n"
          }
        },
        "required": [
          "duration",
          "length"
        ]
      },
      "VehicleTransport": {
        "description": "Information about a transport",
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/VehicleMode"
          }
        },
        "required": [
          "mode"
        ]
      },
      "VehicleTravelSummary": {
        "description": "Total value of key attributes for a route section.",
        "properties": {
          "baseDuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "Duration (in seconds) ignoring time-aware information.\n\nIn particular, dynamic traffic information is not taken into account. Only average\nfree-flow speeds based on historical traffic are used to calculate this duration.\n\nThe `baseDuration` can also be understood as the best possible duration.\n"
          },
          "consumption": {
            "$ref": "#/components/schemas/Energy",
            "description": "Estimated net energy consumption (in kWh) for the travel only.\nDoes not include any charging at stations.\n"
          },
          "duration": {
            "$ref": "#/components/schemas/Duration"
          },
          "length": {
            "$ref": "#/components/schemas/Distance"
          },
          "mlDuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "Duration (in seconds) based on the region-specific machine learning model.\n\n`mlDuration` is calculated for each route section of the route.\nIf a section of the route is not supported, `mlDuration` is not present in the summary of that section and a notice with the reason is provided.\n`mlDuration` is only calculated for the entire section. The sum of span durations is not equivalent to `mlDuration`.\n**Limitations:** only valid for `transportMode=car` or `transportMode=taxi`.\n"
          },
          "tolls": {
            "$ref": "#/components/schemas/TollSummary",
            "description": "Summary of tolls to be paid for this section of the route (if any), grouped as requested in the `tolls` parameter.\nThis element only appears in the response if at least one grouping criteria was requested.\n"
          },
          "typicalDuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ],
            "description": "Duration (in seconds) under typical traffic conditions.\n\nIn particular, dynamic traffic information is not taken into account. Instead,\nspeeds that are typical for the given time of day/day of week based on historical\ntraffic are used to calculate this duration.\n"
          }
        },
        "required": [
          "duration",
          "length"
        ]
      },
      "VehicleType": {
        "description": "Specifies the type of the vehicle\n\n* `straightTruck`: a truck on a single frame with a permanently attached cargo area. **Note:**\ndefault value when truck routing mode is used. **Limitations:** only valid for `transportMode=truck`.\n* `tractor`: a towing vehicle that can pull one or more semi-trailers (aka semi-truck).\n**Limitations:** only valid for `transportMode=truck`.\n",
        "enum": [
          "straightTruck",
          "tractor"
        ],
        "type": "string"
      },
      "VersionResponse": {
        "description": "Returns the versions of the service components.",
        "properties": {
          "apiVersion": {
            "description": "The current version of the API.",
            "type": "string"
          },
          "dataVersions": {
            "description": "Returns the versions of data sets used by the service.",
            "items": {
              "$ref": "#/components/schemas/DataVersion"
            },
            "type": "array"
          },
          "serviceVersion": {
            "description": "The current version of the service.",
            "type": "string"
          }
        },
        "required": [
          "apiVersion"
        ]
      },
      "ViolatedTransportMode": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseNoticeDetail"
          }
        ],
        "description": "Contains details about violated transport mode on this road, e.g., trucks being generally forbidden.\n"
      },
      "WalkAttributes": {
        "description": "Extensible enum: `stairs` `park` `indoor` `open` `noThrough` `tollRoad` `...`  \nWalkAttributes are applied to a span of a route section and describe walk-related attribute\nflags.\n\n* `stairs`: This part of the route is using stairs.\n* `park`: This part of the route is located inside a park.\n* `indoor`: This part of the route is located inside a venue.\n* `open`: This part of the route is open to walking.\n* `noThrough`: This part of the route can only be traversed if origin, destination or any via waypoint is located there.\n* `tollRoad`: This part of the route is restricted with a fee (or toll).\n",
        "type": "string",
        "x-extensible-enum": [
          "stairs",
          "park",
          "indoor",
          "open",
          "noThrough",
          "tollRoad"
        ]
      },
      "Waypoint": {
        "description": "A location defining an origin, destination or via point for a route or an isoline.\n\nFormat: `Place[WaypointOptions]`\n\n* Place: `{lat},{lng}[PlaceOptions]`\n* PlaceOptions: `;option1=value1;option2=value2...`\n* WaypointOptions: `!option1=value1!option2=value2...`\n\nA waypoint consists of:\n* Exactly one place\n* Optional settings for the place\n* Optional settings for the waypoint itself\n\nSupported place options:\n* `course`: int, degrees clock-wise from north. Indicates the desired direction from the place. For example, `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance`. This parameter takes preference over `matchSideOfStreet`.\n* `sideOfStreetHint`: `{lat},{lng}`. Indicates the side of the street that should be used. For example, if the location is to the left of the street, the router will prefer using that side in case the street has dividers. For example, `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north` side of the street should be preferred. This options is required, if `matchSideOfStreet` is set to `always`.\n* `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as well. Note the exception above when combined with `course`.\n  + `always` : Always prefer the given side of street.\n  + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case the street has dividers. This is the default behavior.\n* `nameHint`: string. Causes the router to look for the place with the most similar name. The typical examples include: `North` being used to differentiate between interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly select a residental street.\n* `radius`: int, meters. Instructs the router to consider all places within the given radius as potential candidates for matching the waypoint. This can be either because it is not important which place is used, or because it is unknown. Values higher than 200 meters are not supported. Option cannot be combined with `snapRadius`.\n* `snapRadius`: int, meters. Instructs the router to match the waypoint, within the specified radius, to the most \"significant\" road. In contrast to the regular `radius` parameter, `snapRadius` sorts potential candidates in order of \"significance\". For example, a highway is more significant on a zoomed-out map than a national road, a national road is more significant than a city road, etc. Hence, `snapRadius` cannot be combined with `radius` parameter. The typical use case for `snapRadius` is when selecting a waypoint on a zoomed-out view of a map on a drag-and-drop interface. The expectation on such UIs is that only roads that are visible at that zoom level are considered for matching and a large snapRadius would enable that.\n* `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance. For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions.\n* `segmentIdHint`: string. Causes the router to try and match to the specified segment. Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint. This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one.\n* `onRoadThreshold`: int, meters. allows specifying a distance within which the waypoint could be considered as being on a highway/bridge/tunnel/sliproad. Within this threshold, the attributes of the segments do not impact the matching. Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.\n\nSupported waypoint options:\n* `stopDuration`: desired duration for the stop, in seconds.\n* `passThrough`: boolean. Asks the router to avoid the following during route calculation:\n  + Introducing a stop at the waypoint.\n  + Splitting the route into sections.\n  + Changing the direction of travel.\n\nFollowing scenarios is not supported for `passThrough` parameter:\n  + Setting both `stopDuration` to a value greater than 0 and `passThrough=true`.\n  + Setting `passThrough=true` for `origin` or `destination` of a route.\n  The default value is `false`.\n",
        "type": "string"
      },
      "WebLink": {
        "description": "The URL address to an external resource.",
        "properties": {
          "href": {
            "$ref": "#/components/schemas/Uri"
          },
          "hrefText": {
            "description": "The interactive (or clickable) portion of the text. If not present (default), the entire content of the text attribute will be considered.\n",
            "type": "string"
          },
          "id": {
            "description": "Unique identifier for the web link. It is used to deduplicate links defined in multiple sections.",
            "type": "string"
          },
          "text": {
            "description": "Text describing the url address (e.g. The example website).",
            "type": "string"
          }
        },
        "required": [
          "id",
          "text"
        ]
      },
      "WebLinkWithDeviceType": {
        "description": "The URL address to an external resource.",
        "properties": {
          "deviceType": {
            "description": "Extensible enum: `web` `ios` `android` `...`  \nDevice type for which the link is intended\n",
            "type": "string",
            "x-extensible-enum": [
              "web",
              "ios",
              "android"
            ]
          },
          "href": {
            "$ref": "#/components/schemas/Uri"
          },
          "hrefText": {
            "description": "The interactive (or clickable) portion of the text. If not present (default), the entire content of the text attribute will be considered.\n",
            "type": "string"
          },
          "id": {
            "description": "Unique identifier for the web link. It is used to deduplicate links defined in multiple sections.",
            "type": "string"
          },
          "text": {
            "description": "Text describing the url address (e.g. The example website).",
            "type": "string"
          }
        },
        "required": [
          "id",
          "text"
        ]
      },
      "WeightPerAxleGroup": {
        "description": "Specifies the weights of different axle groups, like single and tandem axles.\n\nThis allows specification of axle weights in a more fine-grained way than `weightPerAxle`. This\nis relevant in countries with signs and regulations that specify different limits for different\naxle groups, like the USA and Sweden.\n\nFormat: `AxleGroup:Weight[,AxleGroup2:Weight2]...`\n\nAllowed axle groups currently are:\n  * `single`\n  * `tandem`\n  * `triple`\n\nWeights are specified in kilograms (kg) and are the total weight of the axle group.\n\n**Note:** `weightPerAxleGroup` and `weightPerAxle` are incompatible.\n**Limitations:** only valid for `transportMode=truck`.\n",
        "example": "single:11000,tandem:18000",
        "type": "string"
      },
      "WheelchairAccessibility": {
        "default": "unknown",
        "description": "Defines accessibility for people with a disability and who use a wheelchair.\n\n* `unknown` - Information is not available.\n* `yes` - Full unrestricted accessibility.\n* `limited` - Accessibility is limited, not everywhere or require assistance.\n* `no` - No accessibility.\n",
        "enum": [
          "unknown",
          "yes",
          "limited",
          "no"
        ],
        "type": "string"
      }
    },
    "securitySchemes": {
      "ApiKey": {
        "description": "A key generated specifically to authenticate API requests. For more information on how to get an API key, see https://developer.here.com/documentation/identity-access-management/dev_guide/index.html.\n",
        "in": "query",
        "name": "apiKey",
        "type": "apiKey"
      },
      "Bearer": {
        "bearerFormat": "JWT",
        "description": "A token obtained from a separate endpoint using client credentials and an OAuth 1.0a HMAC-SHA256 signed request.\nFor more information on how to get a bearer token, see https://developer.here.com/documentation/identity-access-management/dev_guide/index.html.\n",
        "scheme": "bearer",
        "type": "http"
      }
    }
  }
}
